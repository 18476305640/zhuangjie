<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>Java基础 - wolai 笔记</title><link rel="shortcut icon" href="media/16469205437401646920543543_1.png"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon icon-image" style="background-image: url(&quot;media/16469205437401646920543543.png&quot;)"></div></div><div data-title="Java基础" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK<span class="jill"></span>文档：</span><span class="inline-wrap"><a href="https://www.matools.com/api/java8"><span>https://www.matools.com/api/java8</span></a></span></div></div><h4 class="wolai-block"><span class="inline-wrap">1.1 Java<span class="jill"></span>的数据类型</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符串常量：&quot;123&quot;,&quot;abc&quot;</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符常量：&#39;a&#39;,&#39;1&#39;(单引号内没有任何东西会报错，且有仅只有一个字符)</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">整数常量：1，200</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">浮点数常量：1.23,65.1</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">布尔常量：true,false</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">空常量：null (不能直接输出<span class="jill"></span>null)</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.2 基本数据类型与引用数据类型</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">[基本数据类型]</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">整数型 byte short int(默认) long</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">浮点型 float(数后需加<span class="jill"></span>F)  double(默认)</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符型 char</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">布尔型 boolean</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">[引用数据类型]</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符串、数组、类、接口、Lambda</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.3 变量的声明与注意事项</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">成员变量声明后有默认值，如果是在方法内声明后是没有默认值的，且要知道变量声明时可以没有值，但在使用时一定要有值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.4 自动类型转换与强制类型转换</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">【自动类型转换】A:byte,short,char --» int --» long --» float --» double。</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在<span class="jill"></span>int<span class="jill"></span>类型“之下”的变量进行运算时，会转为<span class="jill"></span>int<span class="jill"></span>进行运算，就算是同一类型，也是要转为<span class="jill"></span>int<span class="jill"></span>的。</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">【强制类型转换】</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在自动类型转换下，进行逆向转换时，即小范围转大范围，如果大范围的超过也小范围，数据会溢出，转换得到的结果是已损值。</span></li></ul></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.5 字符编码</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">是一套自然语言与电脑二进制的转换规则，而字符集就是一套编码规则，编码与解码是规则的使用,而蓄编码与解码不同就会出现乱码。</span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">编码介绍：ASCII<span class="jill"></span>字符集是各字符集的原始祖先，它是最基本的字符编码，其它字符集都兼容它，CBKxxx<span class="jill"></span>有<span class="jill"></span>GB2312（简体）-GBK（简繁）-GB18030（简繁和和民族文字）是我囯的编码规则。</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">Unicode<span class="jill"></span>字符集，是万国码，兼容各国家的文字，有<span class="jill"></span>UTF-8,UTF-16,UTF-32<span class="jill"></span>而<span class="jill"></span>UTF-8<span class="jill"></span>是最常用，UTF-8<span class="jill"></span>是可变长度的：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">#128<span class="jill"></span>个<span class="jill"></span>US-ASCII<span class="jill"></span>字符，只需一个字节编码。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">#拉丁文等字符，需要二个字节编码。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">#大部分常用字（含中文），使用三个字节编码。其他极少使用<span class="jill"></span>Unicode<span class="jill"></span>辅助字符，使用四字节编码。</span></div></div></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.6 运算符</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">一元运算符：自增自减运算符</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">二元运算符：赋值运算符、比较运算符、逻辑运算符</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">三元运算符：a&gt;b?a:b;三元运算符结果必须被使用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">加法运算符：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">char、byte、short--&gt;int--&gt;float--&gt;double--&gt;String</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">两个数据类型进行相加时，遵循从小转大运算，如果是与<span class="jill"></span>String<span class="jill"></span>进行运算，会转为<span class="jill"></span>String<span class="jill"></span>再和<span class="jill"></span>String<span class="jill"></span>进行运算</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果是多位相加，则从左到右进行一次两位且逐位运算。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">等号“==”运算符：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">基本数据类型：比较值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">引用数值类型：比较地址值。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">其它运算。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.7 编译器的常量优化</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">short s=5+7<span class="jill"></span>时，在编译后，相当于<span class="jill"></span>short s=12，而不会<span class="jill"></span>5+7<span class="jill"></span>运算后转<span class="jill"></span>int<span class="jill"></span>再赋值给<span class="jill"></span>short<span class="jill"></span>而报错。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">1.8 控制语句</span></h4><h4 class="wolai-block"><span class="inline-wrap">1.9 数组的方法</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">初始化后长度固定 </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">常见异常：数组异常：Exception:ArrayIndexOutOfBoundsException(越界异常）--超出定义的数组长度、NullPointerException（空指针异常）--访问的数组没有指向堆;</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.0 方法</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法的组成：方法修饰符<span class="jill"></span>+[static<span class="jill"></span>或<span class="jill"></span>final]+<span class="jill"></span>方法返回值<span class="jill"></span>+<span class="jill"></span>方法名称(参数列表){[方法体]+[返回语句]};</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方法重载（Overload）:方法名相同，参数列表不同的一系列方法，若在一个类中写了多个这类的方法，就是方法重载了。</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.1 栈与堆</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">栈：当调用方法时，就进栈</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">堆：当<span class="jill"></span>new<span class="jill"></span>时就创建一块空间</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法区：本身运行的类与运行中涉及的类</span></div></div></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.2 构造方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">用来创建类的实例对象。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.3 静态方法与成员方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">静态方法不需要创建对象，用的是类对象</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.4 方法中的<span class="jill"></span>this</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">this<span class="jill"></span>就是要创建出来的对象，所以调用的是对象的成员变量，而右边的是根据最近原则得到的<span class="jill"></span>name，即传入的<span class="jill"></span>name</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Son</span><span class="token punctuation">{</span>
       <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.5 构造方法与普通方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">没有<span class="jill"></span>static<span class="jill"></span>与返回值这两个位置，且要求方法与类名一致。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.6 构造方法的调用 </span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们用<span class="jill"></span>new<span class="jill"></span>调用类的构造方法时，构造方法可能会调用其它构造方法，但不管最后是哪个构造方法，最先执行的是<span class="jill"></span>super()，用来创建父类对象，然后再原路返回执行构造方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.7 JDK<span class="jill"></span>文档的查看方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"> 在左边索引中进行搜索类名或接口名，两次次回车打开详情，首先要看的是这个所属的包、看这个是类、抽象类还是接口。再看其构造方法与方法。Ctrl+R<span class="jill"></span>可进行查找。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.8 匿名对象</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">new 出来直接使用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.9 ArrayList<span class="jill"></span>集合</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">理解：ArrayList<span class="jill"></span>集合叫数组集合，与数组不同的是，它是不定长的且只能存储引用数据类型。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">基本使用：ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;();//数组有[],集合有&lt;&gt;泛型。JDK1.7<span class="jill"></span>开始，右侧的泛型就不用写了，即只写&lt;&gt;即可。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">问题<span class="jill"></span>1：虽然<span class="jill"></span>ArrayList<span class="jill"></span>只能存储引用数据类型，如果想使用基本数据类型，我们可以用数据类型的包装类，它们是引用数据类型的，</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于从<span class="jill"></span>java1.5<span class="jill"></span>开始支持包装类的自动拆装箱，所以我们可以把包装类当然基本类型使用，它们是兼容的。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">byte       Byte</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">short      Short</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">boolean    Boolean</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">char       Charset【特殊】</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int        Integer【特殊】</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">long       Long</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">float      Float</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">double     Double</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">包装类的自动拆箱与装箱</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">arrayList.add(11);//装箱，默认<span class="jill"></span>new Integer(11);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int num=arrayList.get(0);//拆箱,默认<span class="jill"></span>arrayList.get(0).intValue();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList<span class="jill"></span>方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">add(E e) :向后添加指定泛型的一个元素。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">remove(int index) :删除指定索引位置的元素。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">get(int index) :返回此列表中指定位置上的元素。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">size() ：返回此列表中的元素数。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">sort()//重写<span class="jill"></span>Comparator<span class="jill"></span>接口里的<span class="jill"></span>compar<span class="jill"></span>抽象方法，通过返回对象属性的差值进行升降排序。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>for<span class="jill"></span>循环遍历集合：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">for (int i = 0; i &lt; arrayList.size(); i++) { }</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、ArrayList<span class="jill"></span>集合与数组的简要说明</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们可以把<span class="jill"></span>ArrayList<span class="jill"></span>集合当作可不停向里面添加东西的容器，而数组就像已径打包密封好的集装箱</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.0 字符串<span class="jill"></span>String</span></h4><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>额外要记的单词：suffix（后缀）

构建方法：
  通过<span class="token keyword">byte</span>、字符串、数组
接口方法：
  判断两个字符串是否相等：equalsIgnoreCase、equals
  查看是否以什么字符串结尾：<span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  转为<span class="token keyword">byte</span>数组：<span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  获取<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  获取第一次出现的index <span class="token operator">:</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  从字符串池中获取：<span class="token string">""</span> ， <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> ，
  如果改变，就不是池中的了，想要从指向池中的，需要用：<span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 从池中获取
  判断length的length是否为<span class="token number">0</span>：<span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  从后面开始的：<span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  获取字符串长度：<span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  利用正则匹配，判断是否包含：<span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"(.*)txt(.*)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  字符替换：  <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">char</span> oldChar<span class="token punctuation">,</span> <span class="token keyword">char</span> newChar<span class="token punctuation">)</span>
  测试此字符串是否以指定的前缀开头：<span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span>
  截取字符串子集：<span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span>
  转小写：<span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  转大写：<span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  删除任何前导和尾随空格：<span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
  
静态方法：
  将一些类型值转为字符串类型：<span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>可以是很多类型值<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
扩展：
  <span class="token class-name">StringBuffer</span>： 用于经常性的字符串的变化  
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符串：jdk1.8<span class="jill"></span>及以前<span class="jill"></span>String<span class="jill"></span>使用的是<span class="jill"></span>char<span class="jill"></span>数组作为底层，因为每一个<span class="jill"></span>char<span class="jill"></span>占用两个字节而拉丁字符只需要一个字节就可以存储。所以从<span class="jill"></span>jdk1.9<span class="jill"></span>后用<span class="jill"></span>byte<span class="jill"></span>数组作为底层。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内存：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String a=&quot;HelloWorld!&quot;;//底层<span class="jill"></span>byte<span class="jill"></span>数组的内存地址存放在字符串常量池中。可重复利用</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String b=new String(&quot;HelloWorld!&quot;);//不用池子中已存在的，而总是自己创建。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">底层：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">byte[] by={97,98,99};//新字符串底层</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">char[] ch={&#39;A&#39;,&#39;B&#39;,&#39;C&#39;};//旧字符串底层</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">判断：public boolean equals(Object anObject)：//对字符串的内容进行比较。而&quot;==&quot;是进行对象地址的比较。[一定要确保左边是字符串]</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">判断：public boolean equalsIgnoreCase(String anotherString)：忽略大小写，进行比较字符串中的内容。[一定要确保左边是字符串]</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">长度：public int length():返回此字符串的长度。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">截取：public String substring(int beginIndex,int endIndex):返回一个新字符串[a,b)，它是此字符串的一个子字符串。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个参数，代表起始位置，截取到末尾。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">转<span class="jill"></span>char<span class="jill"></span>数组：char[] chars = ab.toCharArray();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">获取底层<span class="jill"></span>byte<span class="jill"></span>数组：byte[] bytes = ab.getBytes();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内容替换： String tm = &quot;你会不会玩啊？你大爷的！&quot;.replace(&quot;你大爷的&quot;, &quot;****&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">分割：String[] split = &quot;123,456,789&quot;.split(&quot;,&quot;);//特别地如果用&quot;.&quot;进行分割，那么就会失败，原因是分割的底层是用了正则，所以我们需要用&quot;\\.&quot;对&quot;.&quot;</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进行转意;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">类型转换：利用包装类的方法进行字符串转数值方法</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符转<span class="jill"></span>Integer<span class="jill"></span>或说<span class="jill"></span>int: Integer.parseInt(&quot;100&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符转<span class="jill"></span>Double<span class="jill"></span>或说<span class="jill"></span>double: Double.parseDouble(&quot;100&quot;);</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.1 修饰符<span class="jill"></span>static</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">内存：用<span class="jill"></span>static<span class="jill"></span>修饰的变量，存在于内存的方法区（Method Area）中的，是该类所有实例对象的&quot;共有&quot;属性，与类的实例对象无关。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.2 Arrays<span class="jill"></span>数组工具类</span></h4><h4 class="wolai-block"><span class="inline-wrap">3.3 Math<span class="jill"></span>数字工具类</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：Math<span class="jill"></span>类是数学相关的工具类，里面提供了大量进行数学运算的静态方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：public static double abs(..)：取绝对值;</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public static double ceil(double a):向上取整</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public static double floor(double a):向下取整</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public static final double PI:代表圆周率的值。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.4 继承</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">子类构造方法调用 ，就会调用 super，super<span class="jill"></span>代表父类。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">重写是方法名相同，参数列表也相同。//可重写为访问修饰扩大，返回值类型缩小。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.5 抽象类</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">类声明上，由<span class="jill"></span>calss<span class="jill"></span>转为<span class="jill"></span>abstract class</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法声明上，声明上由<span class="jill"></span>public 转为<span class="jill"></span>public abstract</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">跟接口一样，不能创建对象 。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">[(顶层抽象类)]--[（抽象子类）--(普通子类)]--普通类</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.6 接口</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">[public] [static] [final] 数据类型 常量名称 =数据值; //介意常量名称这样写，“&quot;MNUM_OF_DEF”。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">[public] [abstract] 返回值类型 方法名称(参数列表);//接口中最重要的内容</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.7 单继承多实现</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.8 父类优先于接口</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">、如果一个类继承了一个类与实现了一个接口，若有冲突，父类优先。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.9 当两个父接口冲突时</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">一个接口继承了多个接口，如果默认方法有冲突，如果这时子接口不覆盖掉父接口的冲突方法，是会报错的，因为两父接口间没有优先级的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.0 多态</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">态(向上转型)：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：父类  对象=new 子类(参数列表);</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用多态对象需遵循：编译（+<span class="jill"></span>属性）父类，运行子类。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">多态的好处与弊端</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">好处：只有父类方法存在有的，才能调用，且成员方法运行看右边（子类）;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">弊端：无法调用子类特有的内容（变量<span class="jill"></span>+<span class="jill"></span>方法），“解决方法：向下转型”;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">向下转型（“还原”解决弊端）</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">理解：向下转型，将子类还原回来了，就不存在多态的特征了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：如果还原回原来的，如果是猫转成了狗，会出现类转换异常（介意转换前用<span class="jill"></span>instanceof<span class="jill"></span>作判</span></div></div></div></div><h4 class="wolai-block"><span class="inline-wrap">4.1 final<span class="jill"></span>修饰</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>final<span class="jill"></span>关键字来修饰类，则这个类不能有子类，即太监类。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>final<span class="jill"></span>关键字来修饰方法，那么这个方法是不能被子类重写的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>final<span class="jill"></span>关键字来局部变量，首先要知道局部变量如果不赋值是没有默认值的，所以声明时没有赋值，则会给予一次赋值的机会。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>final<span class="jill"></span>关键字来成员变量，首先要知道成员变量是有默认值的，如果在初始化时不设置，必须保证所有构造方法都能给其赋值。</span></div></div></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.2<span class="jill"></span>四种权限修饰符</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">private :类外不能访问</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">(default):包外不能访问</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">protected :包外非子类不能访问</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public :都可访问</span></div></div><h4 class="wolai-block"><span class="inline-wrap">4.3 内部类</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">类的权限修饰符</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">外部类：public/(default)  //因为那两种是无意义的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">成员内部类：全部可用 //像成员方法的权限修饰一样</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">局部内部类：全不可用 //因为只能给所在方法使用。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">分类说明：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">成员内部类：跟成员方法同等位置，我们在调用时分可见调用与不可见调用，可见直接<span class="jill"></span>new<span class="jill"></span>即可，不可见调用（外部与本类静态方法）格式：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">外部类.内部类 内部类对象名 = new 外部类().内部类();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">局部内部类：跟局部变量同等位置，只能给所在方法使用。若用到其局部变量，该变量必须是<span class="jill"></span>final,因为生命周期不同。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但从<span class="jill"></span>java 8+<span class="jill"></span>开始，只要保证该局部变量不变，可以省略<span class="jill"></span>final<span class="jill"></span>不写。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">匿名内部类：我们可以将运用多态得到的实现类或子类的对象看作成员变量或局部变量。只使用一次或代码比较少才推荐使用，</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">格式：接口 对象名 = new 接口(){..需要重写接口的全部内部..};</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">父类 对象名= new 父类(){ ..匿名子类体.. };</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：匿名内部类与匿名对象不同，匿名对象忽略的是对象名，而匿名内部类忽略的是实现类或子类（用<span class="jill"></span>{}<span class="jill"></span>代替。）</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.4 接口变量</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">定义接口后，即可拿来当作类型使用。运用多态设置值。(多态，匿名内部类，匿名内部类<span class="jill"></span>+<span class="jill"></span>匿名对象)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.5 根类<span class="jill"></span>Object</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">继承<span class="jill"></span>Object<span class="jill"></span>类，Object 是类层次结构的根类。每个类都直接或间接使用<span class="jill"></span>Object<span class="jill"></span>作为父类，所有对象（包括数组）都实现这个类的方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">toString：不重写<span class="jill"></span>toString<span class="jill"></span>方法默认打印的是类的包名<span class="jill"></span>+<span class="jill"></span>地址值。一般重写为对类属性的打印输出。</span><span class="inline-wrap"><a href="输出引用对象时，默认调用其toString()方法"><span>可快速生成</span></a></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">equals:重写父类<span class="jill"></span>Object<span class="jill"></span>方法，注意<span class="jill"></span>this<span class="jill"></span>代表左边。看传入是否与<span class="jill"></span>this<span class="jill"></span>相等或是否为其类的实例，若为<span class="jill"></span>null，直接返回<span class="jill"></span>false;[可快速生成]</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Objects<span class="jill"></span>工具类</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public boolean equals(String a,String b)方法：可避免<span class="jill"></span>Object<span class="jill"></span>的<span class="jill"></span>equals<span class="jill"></span>方法的空指针异常问题。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String a=null;a.equals(&quot;abc&quot;);//就会出现空指针异常。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String a=null;Objects.equals(a,&quot;abc&quot;);//返回<span class="jill"></span>false</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.6<span class="jill"></span>时间对象-Date</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">构造方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Date( [long time] );根据传入的毫秒值创建日期对象//无参数默认当前系统时间的毫秒值创建对象</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">getTime(); 返回<span class="jill"></span>Date<span class="jill"></span>对象对应的毫秒值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">toString(); 输出默认调用，示例&quot;Fri Sep 25 11:08:36 CST 2020&quot;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">工具：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）文本生成&amp;文本解析</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：SimpleDateFormat--&gt;DateFormat（该抽象类实现了<span class="jill"></span>Serializable, Cloneable<span class="jill"></span>这两个接口）;</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们要想获取指定的日期格式，必不可少的是格式,我们可以利用<span class="jill"></span>SimpleDateFormat<span class="jill"></span>创建一个想要的格式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">示例：SimpleDateFormat sm=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//之间可用一些字符隔开来美化生成的文本。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">y  年</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">M  月</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">d  日</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">H  时</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">m  分</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">s  秒</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">SimpleDateFormat<span class="jill"></span>方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">传入<span class="jill"></span>Date<span class="jill"></span>对象转为指定文本。// String format = sdf.format(date);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">传入文本，按照模式生成<span class="jill"></span>Date<span class="jill"></span>对象。// Date parse = sdf.parse(&quot;2020<span class="jill"></span>年<span class="jill"></span>09<span class="jill"></span>月<span class="jill"></span>16<span class="jill"></span>日 10<span class="jill"></span>时<span class="jill"></span>07<span class="jill"></span>分<span class="jill"></span>58<span class="jill"></span>秒&quot;);</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（2）日期自定义--日历对象</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：Calendar<span class="jill"></span>是一个日历抽象类，我们可以利用其静态方法获取其子类来创建对象。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Calendar c = Calendar.getInstance();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">基本操作方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">c.set(Calendar.MONTH,2);//指定（左边参数）设置值（右边）。[年月日可重载设置]</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">c.add(Calendar.MONTH,2);//指定（左边参数）设置值（this+<span class="jill"></span>右边）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">c.get(Calendar.MONTH)+1;//获取指定的量（外国月份从<span class="jill"></span>0<span class="jill"></span>月开始），年日类同。</span></div></div></div></div></div></div></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.7 集合</span></h4><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>单列集合：
  <span class="token class-name">ArrayList</span>（有序、线程安全）、<span class="token class-name">LinkedList</span>（有序、线程安全）
    主要遍历：<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 、 <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token class-name">HashSet</span>（无序、线程不安全）、<span class="token class-name">LinkHashSet</span>（有序、线程不安全）
    主要遍历：迭代器 <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> （或增强<span class="token keyword">for</span><span class="token punctuation">(</span>类型 变量<span class="token operator">:</span>集合<span class="token punctuation">)</span> ）
    
双列集合：
  <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>k<span class="token operator">-</span>v<span class="token operator">></span>
  <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>k<span class="token operator">-</span>v<span class="token operator">></span>
 
  方法：<span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//添加一个键值对</span>
       <span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据key值获取value值。</span>
       <span class="token function">remove</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除指定键值对</span>
       <span class="token function">containsKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找是否存在</span>
       
  遍历：<span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    
  
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">相关介绍</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">栈：先进后出; 队列：先进先出;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">数组：查询快，修改慢，因为数组的长度是固定的，如果你改变了数组长度，则前后就不是同一数组了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">链表：与数组相反//链表有两种，单向链表与双向链表。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）Collection: 单列集合。其子接口 List&lt;E&gt;与<span class="jill"></span>Set&lt;E&gt;它们的实现类才是我们要使用的。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">List<span class="jill"></span>集合：有索引，可重复。原始集合是<span class="jill"></span>Vector<span class="jill"></span>集合：单线程--&gt;线程安全--&gt;速度慢，jdk1.2<span class="jill"></span>后被更先进的集合取代了。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ArrayList<span class="jill"></span>集合：底层用的是数组（数组长度是固定--&gt;读取快，增删慢）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">LinkedList<span class="jill"></span>集合：底层用的是链表结构（双向），其特点是增删快，查找慢。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Set<span class="jill"></span>集合：无索引，不重复。底层都有哈希表（数组<span class="jill"></span>+<span class="jill"></span>链表/红黑树）</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashSet<span class="jill"></span>集合:底层用的是哈希表。之所以不能存储重复的值是因为在存储时会进行哈希值与<span class="jill"></span>equals<span class="jill"></span>的判断，两者只要两个都不为<span class="jill"></span>true<span class="jill"></span>就可存入。[自定义类型元素要重写<span class="jill"></span>hashCode<span class="jill"></span>和<span class="jill"></span>equals<span class="jill"></span>方法]</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">LinkedHashSet:与<span class="jill"></span>HashSet<span class="jill"></span>集合不同的是，在底层多了一条链表，用于记录元素存入顺序，即怎么添加就怎么存，所以<span class="jill"></span>LinkedHashSet<span class="jill"></span>集合是有序不重复的集合。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（2）Map&lt;k,v&gt;集合：Map<span class="jill"></span>集合是一个双列（key-value），key<span class="jill"></span>不能重复，但值可以重复。//原始集合是:Hashtable<span class="jill"></span>集合：从<span class="jill"></span>JDK1.0<span class="jill"></span>开始就出现了，和<span class="jill"></span>Vector<span class="jill"></span>集合一样，jdk1.2<span class="jill"></span>后被更先进的集合取代了，底层是一张哈希表，是单线程的（所以线程安全且慢），该集合的特点是不能存储空(key<span class="jill"></span>或<span class="jill"></span>value)。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap&lt;k-v&gt;集合: 1.8<span class="jill"></span>之后，底层用的是哈希表（数组<span class="jill"></span>+<span class="jill"></span>单向链表/红黑数（链表长度超<span class="jill"></span>8<span class="jill"></span>时启用）），是一个无序的集合。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">LinkedHashMap&lt;k,v&gt;集合: 与<span class="jill"></span>HashMap&lt;k,v&gt;不同的是,在底层多了一条链表，使其存取有序，且<span class="jill"></span>LinkedHashMap<span class="jill"></span>继承了<span class="jill"></span>HashMap<span class="jill"></span>集合。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：put(k,v);//添加一个键值对</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">get(k);//根据<span class="jill"></span>key<span class="jill"></span>值获取<span class="jill"></span>value<span class="jill"></span>值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">remove(k);//删除指定键值对</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">containsKey(k);//查找是否存在</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">java<span class="jill"></span>单列集合的遍历：我们知道<span class="jill"></span>List<span class="jill"></span>集合是有索引的，所以可以用普通<span class="jill"></span>for<span class="jill"></span>循环来进行遍历，但<span class="jill"></span>Set<span class="jill"></span>是没有索引的，那我们用什么方式遍历它呢？这时我们就需要用迭代器了。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">迭代器</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：集合有一个<span class="jill"></span>iterator() 方法，这个方法调用了<span class="jill"></span>Iterator<span class="jill"></span>实现类的构造方法。即返回了一个迭代器实现类的对象。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashSet&lt;String&gt; str = new HashSet&lt;&gt;();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Iterator&lt;String&gt; it = str.iterator();//多态</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：boolean hasNext() 用来判断集合中是否有下一个元素。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">E next():返回上面说有下一个元素的下个元素，并把指针向后移一位，准备作下一次的判断。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原理：返回集合对应的<span class="jill"></span>Iterator<span class="jill"></span>对象后，指针指向-1<span class="jill"></span>索引（首位是<span class="jill"></span>0），如果用<span class="jill"></span>hasNext<span class="jill"></span>方法，会判断下一个元素即<span class="jill"></span>0<span class="jill"></span>索引位置是否有元素。如果有<span class="jill"></span>next<span class="jill"></span>方法可以取出这个元素（方法执行捂指针向后移一位）。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">增强<span class="jill"></span>for<span class="jill"></span>循环：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：可用来遍历数组与集合，底层是迭代器，下面就用迭代器来理解增强<span class="jill"></span>for<span class="jill"></span>循环。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">格式：for(下一个元素的类型 下个元素的名称：数组或集合对象){}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原理：在增强<span class="jill"></span>for<span class="jill"></span>第三个量中,第三个变量位置会判断是否有下个元素（hasNext()），而第二个变量则代表这&quot;下一个元素&quot;的元素(next())。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">java<span class="jill"></span>双列集合的遍历：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">思路：1、如果我们能将全部元素的<span class="jill"></span>key<span class="jill"></span>转为一个集合，那么我们就通过遍历<span class="jill"></span>key<span class="jill"></span>来遍历集合的<span class="jill"></span>value<span class="jill"></span>了。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、利用<span class="jill"></span>key-value<span class="jill"></span>的映射表（entry）来遍历。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">实现：1、通过用<span class="jill"></span>keySet()方法将集合的<span class="jill"></span>key<span class="jill"></span>转为一个<span class="jill"></span>Set<span class="jill"></span>集合。然后遍历存储<span class="jill"></span>key<span class="jill"></span>的<span class="jill"></span>Set<span class="jill"></span>集合来间接遍历<span class="jill"></span>value。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、Entry<span class="jill"></span>对象在<span class="jill"></span>Map<span class="jill"></span>建立时也随之创建了（结婚证，哈哈），存储着<span class="jill"></span>Map<span class="jill"></span>的<span class="jill"></span>key-value<span class="jill"></span>值。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用<span class="jill"></span>map.entrySet();获取存储<span class="jill"></span>entry<span class="jill"></span>对象的<span class="jill"></span>Set<span class="jill"></span>集合，然后遍历存储<span class="jill"></span>entry<span class="jill"></span>对象的<span class="jill"></span>Set<span class="jill"></span>集合，entry<span class="jill"></span>对象提供了解析的方法<span class="jill"></span>getKey()与<span class="jill"></span>getValue()。</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">其它共有方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">of:JDK9<span class="jill"></span>对集合添加的优化</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">of<span class="jill"></span>是<span class="jill"></span>List、Set、Map<span class="jill"></span>集合接口的静态方法，我们可以直接调用其<span class="jill"></span>of<span class="jill"></span>方法然后添加其元素，对应地返回一个“固定长度”的集合（不能再使用改变长度的方法）。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.8<span class="jill"></span>泛型</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">好处：无需做类型转换且把运行期异常提升到了编译时异常。在使用集合时如果不写泛型，默认是<span class="jill"></span>Object，就需要向下转型使用。//instanceof<span class="jill"></span>判断左边是否是右边的实例。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内容：当一个方法我们不确定要传入什么类型的值时，就可以使用泛型。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">全泛型</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）泛型类与泛型方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">让类替方法问是什么类型。//public class test07&lt;T&gt;{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void getData(T t){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">System.out.println(t);</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如何不需要用类帮忙问，方法自己解决这个问题（如果是单方法使用泛型时），可以参考以下写法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public &lt;T&gt; void show(ArrayList&lt;T&gt; arr){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//方法内部</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">再特别地：使用通配符， 进行简化。（注意：上面的<span class="jill"></span>T<span class="jill"></span>是可以用来代表对象类型的，而通配符&quot;?&quot;是不能的，它表示任意类型。）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void show(ArrayList&lt;?&gt; arr){</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（2）泛型接口的实现类</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：接口的实现类需要这样写：//或将下面的<span class="jill"></span>T<span class="jill"></span>改为具体的类</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class Mee&lt;T&gt; implements Fu&lt;T&gt;{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Override</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void showData(T t) {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//方法内部</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">半泛型</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）上限限定&lt;？ extends E&gt;</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：上面意为，E<span class="jill"></span>类的子孙类（泛型限制）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public interface test07&lt;T extends Number&gt;{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void show(T t);</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">=========================================================</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class test06&lt;T extends  Number&gt; implements test07&lt;T&gt; {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Override</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void show(T t) {</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（2）下限限定&lt;？ super E&gt;</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：E<span class="jill"></span>类的父祖类（泛型限制）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：参考上面</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.9<span class="jill"></span>可变参数：</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：可变参数是一个参数，如果要写多个不同类型的参数，可变参数必须写在最后。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">底层：可变参数是一个参数，实质是个数组。当我们调用传入参数后，这个可变参数的底层数组的长度就确定了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">参数写法：([其它参数],&lt;数据类型&gt;...&lt;变量&gt;)注意中间是三个点,这个变量就是数组变量，相当于&quot;int [] a={<span class="jill"></span>传入参数后确定<span class="jill"></span>}&quot;，、</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></h4><h4 class="wolai-block"><span class="inline-wrap">5.0<span class="jill"></span>异常</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">分类：Exception<span class="jill"></span>包括<span class="jill"></span>Error<span class="jill"></span>错误(编译期异常)与<span class="jill"></span>RuntimeException(运行期异常：当出现异常时，没有处理逻辑下，方法会将这个异常传递到调用者，进行依次传递，当抛到<span class="jill"></span>JVM<span class="jill"></span>虚拟机时，控制台打印红色字体错误信息并终止当前执行的<span class="jill"></span>java<span class="jill"></span>程序。)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">过程分析：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">产生异常：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">捕获：参考下面“捕获处理异常”</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">主动产生：用<span class="jill"></span>throw<span class="jill"></span>关键字，示例：throw new ArrayIndexOutOfBoundException(&quot;越界异常&quot;);//new<span class="jill"></span>的是<span class="jill"></span>RuntimeException（运行期异常）的子类。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">抛出异常(处理异常)：在方法参数列表后写：&quot;throws &lt;Exception<span class="jill"></span>或其子类&gt;,..{} &quot;, 调用者必须处理这个异常，当然也可以选择抛出或<span class="jill"></span>try..catch...;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">捕获处理异常（处理异常）：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">try{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//可能会出现异常的代码</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}eatch(&lt;Exception<span class="jill"></span>或其子类&gt; e){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//捕获到后如何处理异常（一般在工作中，将错误信息写入日志中）</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//Throwable 类是 Java 语言中所有错误或异常的超类,定义有三个方法：e.getMessage();--&gt;e.toString()--&gt;printStackTrace();（信息详细程度向右增强）</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}finally{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//不管是否出现错误，都会执行的代码</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//这里一般放释放<span class="jill"></span>close<span class="jill"></span>语句（在释放时，检查资源是否为<span class="jill"></span>null，为<span class="jill"></span>null<span class="jill"></span>无需释放,JDK1.7,1.9<span class="jill"></span>有了新的处理方案，来简化资源的释放操作）</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：1、可一次捕获多次处理，但要注意异常的顺序（子异常类写在上面）。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、如果<span class="jill"></span>finally<span class="jill"></span>有<span class="jill"></span>return，&quot;会覆盖掉其它地方的<span class="jill"></span>return<span class="jill"></span>语句&quot;。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">3、重写父类方法时，需要与父类方法同步，父类没有抛出异常，子类也是不能抛出的，如果有不能抛出比父类范围大的异常。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">自定义异常：一般重写<span class="jill"></span>Exception<span class="jill"></span>与<span class="jill"></span>RuntimeException(出错不会报错),且分别写一个无参构造方法与有参（String 的错误提示信息）构造方法。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">书写：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class  MyException extends Exception{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public MyException(){ }</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public MyException(String ErrorString){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">super(ErrorString);//信息的传递：自定义---&gt;Exception--&gt;Throwable,来覆盖超类<span class="jill"></span>toString（）原有的错误信息。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">主动抛出异常：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用法：throw new MyException(&quot;出现了**异常&quot;);</span></div></div></div></div></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">5.1 多线程</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">相关介绍：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">并发与并行：并发是一个人吃两个馒头左一口右一口地吃着，并行是两个人同时吃着自己手里的馒头（所以并行速度更快）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进程：进入内存中的程序，如果进程是多进程的，就等于开启了多个线程入口。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程：线程是工具，谁需要就会分配给谁，但切换的时间非常快//线程分两种：分时调度与抢占式调度</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">开启线程：在内存中就开辟了一个栈空间，cpu<span class="jill"></span>根据线程优先级执行各线程。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：一般都是通过实现<span class="jill"></span>Runnable<span class="jill"></span>或继承<span class="jill"></span>Thread<span class="jill"></span>来实现多线程的，且<span class="jill"></span>Thread<span class="jill"></span>类实现了<span class="jill"></span>Runnable<span class="jill"></span>接口，并且<span class="jill"></span>Runnable<span class="jill"></span>只有一个<span class="jill"></span>run<span class="jill"></span>抽象方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）继承<span class="jill"></span>Thread<span class="jill"></span>实现线程：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写线程：继承<span class="jill"></span>Thread<span class="jill"></span>类，[创建一个有参（线程名参数）、无参构造方法]。然后重写<span class="jill"></span>run<span class="jill"></span>方法作为线程的方法体。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用线程：在主线程中创建实现类对象（传入参数），&quot;点&quot;start<span class="jill"></span>方法(父类的方法)来启动线程。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">(2)通过实现<span class="jill"></span>Runnable<span class="jill"></span>接口实现多线程</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写线程：我们可以通过实现<span class="jill"></span>Runable<span class="jill"></span>接口来实现多线程，重写接口的<span class="jill"></span>run<span class="jill"></span>方法（线程体）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">用线程：我们在<span class="jill"></span>main<span class="jill"></span>方法中创建<span class="jill"></span>Runnable<span class="jill"></span>实现类对象<span class="jill"></span>runnable，然后传入:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">new Thread(runable, &lt;线程名&gt;).start();//线程开启了</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">优点：扩展性强（n<span class="jill"></span>实现&gt;1<span class="jill"></span>继承），且设置线程与启动线程进行了分离。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">常用方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">获取线程名:获取线程名的方法是在<span class="jill"></span>Thread<span class="jill"></span>类中的，实现<span class="jill"></span>Runnable<span class="jill"></span>接口的线程要想获取线程名，需要先调用<span class="jill"></span>Thread<span class="jill"></span>的静态方法<span class="jill"></span>currentThread<span class="jill"></span>来获取当前正在执行的线程（得到的是一个对象），然后再调用<span class="jill"></span>getName<span class="jill"></span>方法获取。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread.currentThread().getName();//getName<span class="jill"></span>兄弟方法<span class="jill"></span>setName<span class="jill"></span>方法可以修改线程名。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">休眠方法：sleep(ms);可以让线程睡眠指定时间。它是<span class="jill"></span>Thread<span class="jill"></span>的一个静态方法。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程安全问题：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果多个线程共用相同资源（下面的<span class="jill"></span>num<span class="jill"></span>变量），那么就会出现一些错误，比如下面的抢票系统:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class MyRunnable implements Runnable {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">private int num=100;//注意，不能将<span class="jill"></span>num<span class="jill"></span>变量放到<span class="jill"></span>run<span class="jill"></span>内，不然就不是公共变量了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Override</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void run() {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">while(num&gt;0){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">try {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread.sleep(10);</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">} catch (InterruptedException e) {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">e.printStackTrace();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">System.out.println(&quot;正在卖第&quot;+num+&quot;张票！&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">num--;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">=============================================</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//启动线程</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public static void main(String[] args) {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">MyRunnable myRunnable = new MyRunnable();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread thread01 = new Thread(myRunnable);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread thread02 = new Thread(myRunnable);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread thread03 = new Thread(myRunnable);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">thread01.start();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">thread02.start();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">thread03.start();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">出错的问题：多个线程同时打印输出，都在卖同一张票问题；多个线程同时进行入<span class="jill"></span>if<span class="jill"></span>内，但此时票数为<span class="jill"></span>1，那么后面线程打印输出<span class="jill"></span>0，-1<span class="jill"></span>不存在的问题。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">解决线程安全问题：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">之所以会出现线程安全问题，是共享资源在多个线程的操作下，就会出现程序混乱的问题。只要我们让共享的资源从头到尾只有一个线程在操作即可（同步技术）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同步技术:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">synchronized<span class="jill"></span>介绍:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">(1) synchronized(锁对象){...}，这个锁对象可以你是随便创建的一个对象，但多个线程间用的必须是“同一个实例对象”。因为一个实例对象只有一把锁。谁拿到锁谁就可以执行这个锁对象对应的<span class="jill"></span>synchronized<span class="jill"></span>包围的代码块（不同的锁对象，不能实例同步）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">(2)synchronized(类锁){...}，除了对类实例对象进行锁来实例同步外，我们还可以用某个普通类（类名.class）来作为锁，也可以实现同步。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">内容：有三种方法可实现同步技术。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同步代码：synchronized (&lt;this/.class&gt;) {...} //同步块，锁的是 () 中的对象。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">同步修饰：public synchronized void isok(){...}//同步普通方法，锁的是当前对象。同步静态方法，锁的是当前 Class 对象。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Lock<span class="jill"></span>工具: Lock<span class="jill"></span>是接口，它的实现类是<span class="jill"></span>ReentrantLock。我们需要创建对象(可多态)。然后使用方法来实现同步功能。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">lock();//获取锁</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">unlock();//释放锁</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程的状态:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">叙述：new 后是初始化状态，start<span class="jill"></span>后是可运行状态，可运行状态抢到&quot;时间片&quot;后是运行状态，时间片用完后是阻塞状态，</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果运行中没拿到锁就会进入锁池队列中，如果运行中调用了<span class="jill"></span>wait<span class="jill"></span>方法就进入了等待队列，程序运行完后是死亡状态。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程间的通信：两个具有合作关系的线程，就需要进行通信，那么就要用到同一个<span class="jill"></span>Object<span class="jill"></span>对象的<span class="jill"></span>wait()与<span class="jill"></span>notify()方法，但这两个必须要在“锁”中使用。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//包子类</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class BaoZi {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String pi;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">String xian;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">boolean flag=false;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//包子铺线程</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class BaoZiPu extends Thread {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">private BaoZi bz;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public BaoZiPu(BaoZi bz){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">this.bz=bz;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Override</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void run(){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">synchronized (bz) {</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//此处对公共资源进行锁住操作//Object<span class="jill"></span>的<span class="jill"></span>wait()与<span class="jill"></span>notify()</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//吃货线程</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public class ChiHuo extends Thread{</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">private BaoZi bz;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public ChiHuo(BaoZi bz){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">this.bz=bz;</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Override</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">public void run(){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">synchronized (bz){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">//此处对公共资源进行锁住操作//Object<span class="jill"></span>的<span class="jill"></span>wait()与<span class="jill"></span>notify()</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">线程池</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">原理：创建一个线程池，可以用<span class="jill"></span>LinkedList<span class="jill"></span>集合用来存储线程(泛型为<span class="jill"></span>Thread)，</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">add（new Thread(XXX)）方法添加，</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Thread t=list.remove(0);获取，</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>list.add(t)归还。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">但从<span class="jill"></span>JDK1.5<span class="jill"></span>之后，JDK<span class="jill"></span>就内置了线程池供我们使用了。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用介绍：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">说明：Executors<span class="jill"></span>线程池工具类有一个<span class="jill"></span>newFixedThreadPool<span class="jill"></span>方法，可以创建<span class="jill"></span>Executor<span class="jill"></span>的子接口<span class="jill"></span>ExecutorService<span class="jill"></span>的对象，它就是我们要的线程池。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ExecutorService es = Executors.newFixedThreadPool(2);//创建线程池</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">es.submit(&lt;RunnableImpl&gt;);//submit(Runnable task)利用线程池的方法，执行线程任务。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">es.shutdown();//销毁线程池，一般不用这个方法。</span></div></div></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">6、Lambda<span class="jill"></span>表达式</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">简化匿名内部类的写法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：要求接口必须只有一个抽象类，满足就可以用<span class="jill"></span>Lambda<span class="jill"></span>对接口进行重写来作为参数传递。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">()-&gt;{}<span class="jill"></span>表示的是接口实现类中要唯一要重写的抽象方法，且括号内是抽象方法的形参（不能是实参）。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">两种常见写法如下：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">new Thread(runnable).start();==&gt;new Thread(()-&gt;{}).start();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Runnable s=()-&gt;{};//多态</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">关于<span class="jill"></span>Lambda<span class="jill"></span>的精简:</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">左边：()中可以不写数据类型，但不能一个写一个不写。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">左边：()中如果只有一个参数，可以省略小括号。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">右边：{}<span class="jill"></span>中如果只有一条语句，可以忽略大括号。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">右边：{}<span class="jill"></span>中如果只有一条返回语句，可以忽略<span class="jill"></span>return<span class="jill"></span>与大括号；</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">再优化，方法的引用 ：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">接口 x=&lt;方法隶属者&gt;::方法名;//如果有重载方法，会自动选择与接口抽象方法的参数、返回值一致的方法来作为重写方法，要注意的是如果是构造方法方法名要改为<span class="jill"></span>new，即&lt;方法隶属者&gt;::new。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意事项：如果在在<span class="jill"></span>Lambda<span class="jill"></span>表达式中引用了 方法的变量（闭包），那么这个变量需要被<span class="jill"></span>final<span class="jill"></span>修饰这常量，这像局部内部类一样。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">5.2 File<span class="jill"></span>类</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">构造方法</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">File(参数列表) //里面可以有两个参数（头尾关系），File<span class="jill"></span>与<span class="jill"></span>String，String<span class="jill"></span>与<span class="jill"></span>String,如果是单参数那就是<span class="jill"></span>String.</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">静态方法</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">File.pathSeparator 他是一个与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">成员方法</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">File<span class="jill"></span>解析</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">getAbsolutePath()  会判断是否相对还是绝对路径，如果是相对路径转为以项目路径为<span class="jill"></span>parent<span class="jill"></span>来组装</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">getPath()  将此<span class="jill"></span>File<span class="jill"></span>转换为路径名字符串,类似于<span class="jill"></span>toString()方法</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">getName()  返回<span class="jill"></span>File<span class="jill"></span>表示的文件或目录的名称</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">length() 返回由此<span class="jill"></span>File<span class="jill"></span>表示的文件的字节大小</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">判断<span class="jill"></span>File<span class="jill"></span>表示的内容</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">exist()  判断文件或文件夹是否存在</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">isDirectory()  断判当前路径代表的是文件还是文件夹,是文件夹返回<span class="jill"></span>true，如果不存在，返回<span class="jill"></span>false</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">isFile() 断判当前路径代表的是文件还是文件夹,是文件返回<span class="jill"></span>true,如果不存在，返回<span class="jill"></span>false</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>File<span class="jill"></span>创建文件或文件夹</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">createNewFile() 当且仅当，路径正确，要创建路径代表文件，返回<span class="jill"></span>true;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">mkdir() 当且仅当，路径正确，且只要创建一个文件夹时，返回<span class="jill"></span>true;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">mkdirs() 当且仅当，路径正确，且可创建文件夹，返回<span class="jill"></span>true</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据<span class="jill"></span>File<span class="jill"></span>遍历文件夹下的文件与文件夹</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">list() 返回当前文件夹下的所以文件与文件夹名称，是一个<span class="jill"></span>List&lt;String&gt;集合</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">listFiles() 返回当前文件夹下的所以文件与文件夹的绝对路径，是一个<span class="jill"></span>List&lt;File&gt;集合</span></div></div></div></div></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">5.3 IO<span class="jill"></span>流</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">概述：I（input）O(Output),由硬盘到内存是输入流，反之是输出流。且分为两种：字节流与字符流。但不管是什么流，数据写入与写出时，jvm<span class="jill"></span>虚拟机都要与操作系统进行通信，才能进行操作。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字节流：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">构造方法：输出流（FileOutStream）与输入流（FileInputStream）都要传入文件（File<span class="jill"></span>对象或<span class="jill"></span>String）这个参数，如果是输出流，还可以写布尔值，它表示写入的内容是否追加。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">方法：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">输出流：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">write(int b) :一次写一个字节</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">write(byte[] b) :向<span class="jill"></span>File<span class="jill"></span>中写入字符串，可以用<span class="jill"></span>String<span class="jill"></span>的<span class="jill"></span>getBytes()方法来获取底部<span class="jill"></span>Byte<span class="jill"></span>数组来作为参数。如果单纯写入数字，要注意是负数会和后面的一个参数结合查找系统码表。如果是正数且<span class="jill"></span>0-127<span class="jill"></span>会查找<span class="jill"></span>ASCII<span class="jill"></span>表。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">write(byte[] b, int off, int len) :定入一个字节数组的部分。off<span class="jill"></span>是开始索引，len<span class="jill"></span>字节长度。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">一般用来获取输入流的缓冲器读取的有效字节，而<span class="jill"></span>len<span class="jill"></span>参数是有效的缓冲器<span class="jill"></span>byte<span class="jill"></span>数组存储的有效字节数。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">[案例]：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileOutputStream fos = new FileOutputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\a.txt&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">byte[] bytes ={-65,-66,-67,68};//要写入的数据</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fos.write(bytes);//将数据写入</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fos.close();/关闭输出流，释放内存</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">输入流：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">read(byte[]b)：read<span class="jill"></span>方法可以读取输入流<span class="jill"></span>fis<span class="jill"></span>对象中指定文件，参数<span class="jill"></span>byte<span class="jill"></span>数据也称为缓冲器（一次读取的字节数，用来提高输入效率）</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">并返回真正有效读取的字节数。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">read() :一次读取一个字节，且返回此字节的十进制数。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">[案例]：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileInputStream fis = new FileInputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\a.txt&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">byte[] bt=new byte[2];//缓冲器</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int len=0;//一次读取到的有效的字节数量</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">while((len=fis.read(bt))!=-1){//比如读取&quot;1234567&quot;,如果缓冲器容器是<span class="jill"></span>3，可以读取三次分别是&quot;123&quot;,&quot;456&quot;,&quot;756&quot;,最后一次只有<span class="jill"></span>7<span class="jill"></span>有效，返回<span class="jill"></span>1，下一次返回-1。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">System.out.print(new String(bt,0,len));</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fis.close();</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">案例：文件的复制（复制是两个容器数据的传输，不要怕，这只是输入输出流的紧密结合）</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">long start = System.currentTimeMillis();//开始计时</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileInputStream fis = new FileInputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\jQuery.zip&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileOutputStream fos = new FileOutputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\复制\\jQuery.zip&quot;);//输出流<span class="jill"></span>1</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">byte [] bt=new byte[1024*10];//输入与输出的“结点”2</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int len=0;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">while ((len=fis.read(bt))!=-1){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fos.write(bt,0,len);//输出流<span class="jill"></span>3</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fos.close();//输出流<span class="jill"></span>4</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fis.close();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">long end = System.currentTimeMillis();//计时<span class="jill"></span>end</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">System.out.println(&quot;共耗时&quot;+(end-start)+&quot;毫秒&quot;);</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用字节流读取中文的问题：因为在<span class="jill"></span>GBK<span class="jill"></span>中一个中文占两个字节，但在<span class="jill"></span>UTF-8<span class="jill"></span>中一个中文占三个字节，如果我们用字节来读取，是会出现中文乱码的，使用字符流可以解决此问题。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符流:字符流不能复制非文本文件，复制了也就是损坏状态，一般复制用字节流就可以了。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">读取：FileReader<span class="jill"></span>类继承了<span class="jill"></span>Reader<span class="jill"></span>接口，下面我们就用<span class="jill"></span>FileReader<span class="jill"></span>类与其<span class="jill"></span>read<span class="jill"></span>方法来读取文件。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileReader fr = new FileReader(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\a.txt&quot;);//与字节流的<span class="jill"></span>FileInputStream<span class="jill"></span>一样。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">char[] chars = new char[1024]; \\字符缓冲器</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int len=0; \\读取到的有效字符数</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">while ((len=fr.read(chars))!=-1){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">System.out.println(new String(chars,0,len));</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fr.close();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">写入：FileWriter<span class="jill"></span>类继承了<span class="jill"></span>Writer<span class="jill"></span>类，下面我们就用<span class="jill"></span>FileWriter<span class="jill"></span>类与其<span class="jill"></span>write<span class="jill"></span>方法将数据定入文件。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileWriter fw = new FileWriter(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\a.txt&quot;,true);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fw.write(&quot;一只喵<span class="jill"></span>zjazn&quot;+&quot;\r\n&quot;);//可以传入字符数组，还可以选择数组的点长。字符数组也可以改为字符串。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">fw.close();// fw.flush();这两个方法都会把<span class="jill"></span>write<span class="jill"></span>写入内存中的数据写入到文件中，但<span class="jill"></span>close<span class="jill"></span>会释放掉该内存资源。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缓冲流:一个新手送餐员，一次送一份，老手一次送<span class="jill"></span>N<span class="jill"></span>份。这里的份数是我们定义的&quot;缓冲器(byte<span class="jill"></span>或<span class="jill"></span>char<span class="jill"></span>数组)&quot;，装满后<span class="jill"></span>JVM<span class="jill"></span>才去向操作系统请求。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缓冲流：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字节流：BufferedInputStream(字节输入流)，BufferedOutputStream(字节输出流)。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符流：BufferedReader(字符输入流)，BufferedWriter(字符输出流)。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">缓冲流的使用：(比如字符输入流)</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">FileReader fe = new FileReader(&quot;C:\\a.txt&quot;);</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">BufferedReader bfe=new BufferedReader(fe);//fe<span class="jill"></span>被<span class="jill"></span>bfe<span class="jill"></span>替换，后面代码一致。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##对于字符输入流有一方法相区别于<span class="jill"></span>read<span class="jill"></span>的<span class="jill"></span>readLine<span class="jill"></span>方法，没有行后返回<span class="jill"></span>null，有返回行中的内容，但存在一个问题--“无法换行”，只需再调用<span class="jill"></span>newLinky<span class="jill"></span>方法即可，它会根据系统自动添加换行符。</span></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">转换流：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">InputStreamReader<span class="jill"></span>与<span class="jill"></span>OutputStreamWriter<span class="jill"></span>转换流是为字节流服务的流，可以将字节流转为指定字符集的字符流，相区别于<span class="jill"></span>FileReader<span class="jill"></span>与<span class="jill"></span>FileWrite（默认字符流），它更灵活。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">示例：文件编码的转换</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\a.txt&quot;),&quot;UTF-8&quot;);//读取<span class="jill"></span>UTF-8<span class="jill"></span>文本文件</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\b.txt&quot;),&quot;GBK&quot;);//写为<span class="jill"></span>GBK<span class="jill"></span>编码文本</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">char [] ca=new char[1024*5];</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">int len =0;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">if((len=isr.read(ca))!=-1){</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">osw.write(ca,0,len);</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">osw.close();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">isr.close();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">序列化流与反序列化流</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：将对象写入文件中，写入用到<span class="jill"></span>ObjectOutputStream<span class="jill"></span>序列化流的<span class="jill"></span>OutputObject<span class="jill"></span>方法，读取用<span class="jill"></span>ObjectInputStream<span class="jill"></span>反序列化流的<span class="jill"></span>InputObject<span class="jill"></span>方法。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">序列化流把对象写入</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##被序列化的对象对应的类必须有特定的标记或继承有标记的类（类实现<span class="jill"></span>Serializable<span class="jill"></span>类就有标记），如果没有，该类的实例对象就不能被序列化（报<span class="jill"></span>NotSerializableException<span class="jill"></span>异常）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\c.txt&quot;));</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">oos.writeObject(new BiaoJi(&quot;我的小美女&quot;,12));</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">oos.close();</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">反序列化读取存储在文件中的对象</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##反序列化的条件是，类的<span class="jill"></span>seriaVersionUID<span class="jill"></span>与文件中的对象的相等，假如序列化后对类进行了小改动，导致了<span class="jill"></span>seriaVersionUID<span class="jill"></span>发生了改变，这是我们不希望的，这时我们可以在类中进行固定<span class="jill"></span>seriaVersionUID<span class="jill"></span>值。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##private static final long serialVersionUID=&lt;固定数值&gt;L; //如果该类继承了该类，子类的<span class="jill"></span>UID<span class="jill"></span>默认是父类的;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\Users\\Admin_yfdsou\\Desktop\\c.txt&quot;));</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">BiaoJi o = (BiaoJi)ois.readObject();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">ois.close();</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##我们知道成员变量被<span class="jill"></span>static<span class="jill"></span>修饰后，就不属于该类实例对象的了，而是共享的，属于类。那么将实例对象进行序列化是不存在这些静态变量或方法的。除此被<span class="jill"></span>transient（瞬态）关键字修饰也是，但它只起不被序列化的作用。</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">序列化集合</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">将对象存储在一个集合中，然后将这个集合对象进行序列化，注意在反序列对象的强转时，以这个的格式转换(示例)：ArrayList&lt;Person&gt; list=(ArrayList&lt;Person&gt;)o;</span></div></div></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">打印流<span class="jill"></span>PrintStream</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">介绍：PrintStream<span class="jill"></span>继承了字节输出流<span class="jill"></span>FilterOutputStream，构造方法可以是文件对象/文件路径（String）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">成员变量：</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">print/println(...)：//相当于&lt;PrintStream<span class="jill"></span>对象&gt;.write(&quot;要在控制台输出的内容&quot;.getBytes());</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">##&quot;System.out.println()&quot; ：System.out<span class="jill"></span>是一个<span class="jill"></span>PrintStream<span class="jill"></span>对象，指定了控制台，我们可以用<span class="jill"></span>System<span class="jill"></span>的静态方法<span class="jill"></span>setOut(PrintStream out) 来改变输出位置（可在输出到文件中）。</span></div></div></div></div></div></article><footer></footer></body></html>