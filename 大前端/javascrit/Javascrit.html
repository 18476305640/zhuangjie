<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>Javascrit - wolai 笔记</title><link rel="shortcut icon" href="media/images_1.png"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon icon-image" style="background-image: url(&quot;media/images.png&quot;)"></div></div><div data-title="Javascrit" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">基础</span></h2><h3 class="wolai-block"><span class="inline-wrap">基本知识</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据类型</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据类型</span><span class="inline-wrap">
</span><span class="inline-wrap">在<span class="jill"></span>js<span class="jill"></span>中有六种数据类型</span><span class="inline-wrap">
</span><span class="inline-wrap">（基本数据类型）
String ：在双引放单引
Number :包括整数与浮点数；
如何数值超过<span class="jill"></span>Number.Max_value<span class="jill"></span>则会返回<span class="jill"></span>infinity(无穷的数值类型)；NaN<span class="jill"></span>也是一个数值类型。但他想表示这不是一个数值类型；对于精确度比较高的，千万不要使用<span class="jill"></span>JS<span class="jill"></span>运算，比如<span class="jill"></span>0.1+0.2<span class="jill"></span>得到的结果不准确。
Boolean
Null :使用<span class="jill"></span>typeof<span class="jill"></span>检查是<span class="jill"></span>Object<span class="jill"></span>类型
Undefined <span class="jill"></span>未定义，当我们声明一个变量，但没有赋值，输出时就会返加<span class="jill"></span>Undefined
（引用数据类型）
Object	对象</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据类型的判断函数</span><span class="inline-wrap">
</span><span class="inline-wrap">1-1、typeof <span class="jill"></span>不可以判断<span class="jill"></span>null Object
1-2、instanceof <span class="jill"></span>对<span class="jill"></span>typeof<span class="jill"></span>进行补充，用来判定<span class="jill"></span>Object(具体)
语法： 目标<span class="jill"></span> instanceof  <span class="jill"></span>类型<span class="jill"></span> ----判断左边是否是右边的实例
   1-3、“===” <span class="jill"></span>对<span class="jill"></span>typeof<span class="jill"></span>进行补充, 可以用来判断 null undefined</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据类型的转换</span><span class="inline-wrap">
</span><span class="inline-wrap">1、a.toString()与<span class="jill"></span>String(a)函数转字符串
---前者有局限性，当<span class="jill"></span>a<span class="jill"></span>是<span class="jill"></span>null<span class="jill"></span>或<span class="jill"></span>Undefined<span class="jill"></span>类型时，会出现错误。
2、Number(a)函数转为数值类型
--null、boolean<span class="jill"></span>比较特别，他在一定方面代表的是数字，会转为数字。而不是<span class="jill"></span>NaN;
3、转布尔值的<span class="jill"></span>Boolean(a)函数(比较重要)
--【数字类型】0，NaN【字符类型】空串 &quot;&quot;以及【null】【Undefined】【Object】上面除了<span class="jill"></span>Object<span class="jill"></span>都转为<span class="jill"></span>false</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">转意字符</span><span class="inline-wrap">
</span><span class="inline-wrap">\n <span class="jill"></span>换行<span class="jill"></span>   对应<span class="jill"></span>HTML  </span><span class="inline-wrap">
</span><span class="inline-wrap">
  \t <span class="jill"></span>制表(tab)   对应<span class="jill"></span>HTML   </span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数值解析</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数字解析</span><span class="inline-wrap">
</span><span class="inline-wrap">parseInt(a)，parseFloat(a)两个函数
列举：0.123.4c.123
---parseInt(a),解析得<span class="jill"></span>0，原理是从左到右只解析数字，遇非数字结束。除此还可以用来解析进制数<span class="jill"></span>parseInt(123,8)
深入应用：
如何获取<span class="jill"></span>var i=134;的百十个位数呢？
答：var bai=parseInt(i/100);
var shi=parseInt((i%100)/10);
var ge=i%10;
快速理解：先<span class="jill"></span>% <span class="jill"></span>后<span class="jill"></span>parseInt()+&quot;/&quot;</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>        <span class="token operator">--</span><span class="token operator">-</span><span class="token function">parseFloat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>，解析得<span class="token number">0.123</span><span class="token punctuation">,</span>从左到右解析数值，包括第一个小数点。</pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">字符解析</span><span class="inline-wrap">
</span><span class="inline-wrap">以<span class="jill"></span>0x、0、0b<span class="jill"></span>开头分别代表什么进制数，分别是十六进制、八进制、十进制。
&#39;\u + 16<span class="jill"></span>进制的<span class="jill"></span>unicode<span class="jill"></span>编码&#39;
&#39;&amp;# + 10<span class="jill"></span>进制的<span class="jill"></span>unicode<span class="jill"></span>编码 + 英文分号;&#39;</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运算</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">运算符<span class="jill"></span>+</span><span class="inline-wrap">
</span><span class="inline-wrap">不同数据类型进行加法运算, 主要看一对运算中是否有<span class="jill"></span>String、NaN.且优先级<span class="jill"></span>String&gt;NaN,
举例：1+null+&quot;abc&quot;=1abc</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非加运算符-*%</span><span class="inline-wrap">
</span><span class="inline-wrap">不管是何类型都转为<span class="jill"></span>Number<span class="jill"></span>运算。结果不是数字就是<span class="jill"></span>NaN; 
--原理是，从左到右将非数字类型转为数字类型如果转换失败，得到<span class="jill"></span>NaN,因为所有数值与<span class="jill"></span>NaN<span class="jill"></span>运算都是<span class="jill"></span>NaN,所以结束是<span class="jill"></span>NaN.</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">等号与自增自减运算</span><span class="inline-wrap">
</span><span class="inline-wrap">等号运算，“==”与“===”的区别在于是否会作转换，“===”是作全等运算。而“==”转换数据类型转换后进行全等运算。</span><span class="inline-wrap">
</span><span class="inline-wrap">自增有<span class="jill"></span>a++，++a 区别在于第一次代表的值。而后面他的值是一样的，都是自增后的值。
例举： var a=1;
var b=1;
 	console.log(a++,++b);//第一次，</span><span class="inline-wrap"><i>1 2</i></span><span class="inline-wrap">
console.log(a,b);//第二次，</span><span class="inline-wrap"><i>2 2</i></span><span class="inline-wrap">
（-- 略）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">三目运算</span><span class="inline-wrap">
</span><span class="inline-wrap">Boolean  ? A<span class="jill"></span>区：B<span class="jill"></span>区;三目运算符可以是语句块，也可以是某个值。
--补充：如果区是代码块最终变量是没能得到值的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">赋值运算</span><span class="inline-wrap">
</span><span class="inline-wrap">a=4<span class="jill"></span>与<span class="jill"></span>a[+-*/%]=b
--前者是单纯的赋值运算，而后者是表达式赋值。
--后者：a+=b  ==&gt; a=a+b;</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">逻辑运算</span><span class="inline-wrap">
</span><span class="inline-wrap">首先将两边代码结果进行 ”布尔化“，根据&amp;&amp; （||），
进行从左到右找<span class="jill"></span>false(true)。如果找到返回位置上对应的内容，如果没找到返回最后一位的内容。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">关系运算</span><span class="inline-wrap">
</span><span class="inline-wrap">a&gt;b,类似运算中，会将他们数值化，如果都是字符类型则不会数值化，而是比较他们的<span class="jill"></span>Unicode<span class="jill"></span>编码。如果在数值化过程中转为了<span class="jill"></span>NaN,则最后结束是<span class="jill"></span>false.</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">语句</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">条件语句</span><span class="inline-wrap">
</span><span class="inline-wrap">if<span class="jill"></span>语句： 完整语句体
if(Boolean){</span><span class="inline-wrap">
</span><span class="inline-wrap">switch<span class="jill"></span>语句
switch(i){
case a:
代码体<span class="jill"></span>1
break;
case b:
代码体<span class="jill"></span>2
break;
default:
代码块<span class="jill"></span>3
break;
}</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>     <span class="token punctuation">}</span><span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token keyword control-flow">else</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span></pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">循环语句</span><span class="inline-wrap">
</span><span class="inline-wrap">共性：初始化表达式、条件表达式、更新表达式。</span><span class="inline-wrap">
</span><span class="inline-wrap">【循环语句<span class="jill"></span>while】while<span class="jill"></span>的结构是分散的。写法是从死循环到标准。
【循环语句<span class="jill"></span>for】for<span class="jill"></span>循环语句与<span class="jill"></span>while<span class="jill"></span>相比，for<span class="jill"></span>的结构是在一起的。而执行的顺序如下：
for(1<span class="jill"></span>初始化表达式;2,5/,8/...条件表达式;4,7,...更新表达式){
3,6,...代码块
}</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">补充</span><span class="inline-wrap">
</span><span class="inline-wrap">break(switch || 循环) ，continue<span class="jill"></span>专门用于循环</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对象</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">存储不同数据类型的容器，
可以向里面添加任意的数据类型，包括对象，函数，数组与其它对象。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">工厂创建</span><span class="inline-wrap">
</span><span class="inline-wrap">工厂模式
将公共方法存到原型对象中，从而避免每创建一个对象就创建一个属性，来节省内存空间。
function Pro(name,age){
this.name=name;
this.age=age;
Pro.prototype.setName=function (newName){
this.name=newName;
}
}
var pro=new Pro(&quot;小庄&quot;,23);
补充：
this<span class="jill"></span>代表新创建的对象</span><span class="inline-wrap">
</span><span class="inline-wrap">new<span class="jill"></span>就是调用了构造函数进行创建，其执行流程：
1、立刻创建一个新的对象，
2、将新建的对象设置为函数中<span class="jill"></span>this,在构造函数中可以使用<span class="jill"></span>this<span class="jill"></span>来引用新建的对象
3、逐行执行函数中的代码//由我们书写，其它步骤不可见
4、将新建的对象作为返回值返回</span><span class="inline-wrap">
</span><span class="inline-wrap">使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。通过一个构造函数创建的对象，称为是该类的实例。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">添加</span><span class="inline-wrap">
</span><span class="inline-wrap">用方法添加
--obj.nama  =&quot;</span><span class="inline-wrap">&quot;;
obj[&quot;name&quot;]=&quot;</span><span class="inline-wrap">&quot;;
用快捷表达法添加
{
name:123,
&quot;123&quot;:345
}
注意向对象添加的属性名可以不用符合标签符命名规则，但添加的方式需要用引号括起。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读取</span><span class="inline-wrap">
</span><span class="inline-wrap">普通
obj.element
特殊（对应添加）
obj[&quot;123&quot;]</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">查找</span><span class="inline-wrap">
</span><span class="inline-wrap">检查<span class="jill"></span>obj<span class="jill"></span>是否包含有<span class="jill"></span>element<span class="jill"></span>属性
var  ifs=(&quot;element&quot; in obj);</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">删除</span><span class="inline-wrap">
</span><span class="inline-wrap">删除<span class="jill"></span>obj<span class="jill"></span>中的<span class="jill"></span>element<span class="jill"></span>属性
dellete  obj.element</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">遍历</span><span class="inline-wrap">
</span><span class="inline-wrap">枚举
for(var n in obj){
console.log(n+&quot;:&quot;+obj[n]);
//如果<span class="jill"></span>obj.n<span class="jill"></span>是在<span class="jill"></span>obj<span class="jill"></span>中找属性名为<span class="jill"></span>n 的属性值，但肯定是没有的，我们需要《样做。
}</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原型对象</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">原型对象：
不管在<span class="jill"></span>Object<span class="jill"></span>对象，函数(包括<span class="jill"></span>Function<span class="jill"></span>函数)，还是实例对象中，都有原型对象。且他们是存在有关系的。（请看附件）</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">属性的查找</span><span class="inline-wrap">
</span><span class="inline-wrap">关于检查：
hasOwProperty：用来检查对象本身是否含有指定的属性
pro.hasOwnProperty(&quot;name&quot;)
&quot;属性&quot; in 对象.用来检查本身及其原型是否包含指定属性。
举例：
function Pro(name){
this.name=name;
}
var pro=new Pro(&quot;孙悟空&quot;);
pro.</span><span class="inline-wrap"><b>proto</b></span><span class="inline-wrap">.age=23;
console.log(pro.hasOwnProperty(&quot;name&quot;));
console.log(&quot;age&quot; in pro);</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">函数</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">函数本身也是对象，里面包含了可执行的代码。函数用来实现特定的功能。
分类：
(函数本身也是对象)
var at3=new Function(&quot;console.log(&#39;原始&#39;);&quot;);
at3();
 （有函数名）
function fun1(){</span><span class="inline-wrap">
</span><span class="inline-wrap">对象中的函数
--方法</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>    <span class="token punctuation">}</span>
  <span class="token punctuation">(</span>无函数名<span class="token punctuation">)</span>
    有接收<span class="token operator">:</span>
    <span class="token keyword">var</span> <span class="token function-variable function">fun</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      
    <span class="token punctuation">}</span>
    无接收（立即执行函数）<span class="token operator">:</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span></pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">作用域</span><span class="inline-wrap">
</span><span class="inline-wrap">全局变量作用域生命周期是由网页打开到关闭。
而函数变量（局部）作用域从调用到调用结束。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">this</span><span class="inline-wrap">
</span><span class="inline-wrap">在函数中，用对象调用，this<span class="jill"></span>就是该对象。
在函数中，用函数的返回值调用，this<span class="jill"></span>是<span class="jill"></span>Window.
在构造函数中，this<span class="jill"></span>代表的是新创建的对象。</span><span class="inline-wrap">
</span><span class="inline-wrap">改变<span class="jill"></span>this:
Per.call(obj,2,3);//依次传参
Per.apply(obj,[2,3]);//以数组的形式传参</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">类数组<span class="jill"></span>arguments</span><span class="inline-wrap">
</span><span class="inline-wrap">arguments，在函数中<span class="jill"></span>arguments<span class="jill"></span>包含了传进来的所以参数，而不限于形参。
arguments<span class="jill"></span>是一个类数组，我们可以获取里面的包含的参数。</span><span class="inline-wrap">
</span><span class="inline-wrap">我们也可以将这个类数据转为真正的数组。
var args = Array.prototype.slice.call(arguments);</span><span class="inline-wrap">
</span><span class="inline-wrap">除此
我们还可以利用其<span class="jill"></span>cellee<span class="jill"></span>属性得到最近最近外围的函数。来实现递归。
var num=1;
function fu(){
console.log(num++);
arguments.callee();//相当于<span class="jill"></span>fu()</span><span class="inline-wrap">
</span><span class="inline-wrap">}
fu();</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">垃圾回收</span><span class="inline-wrap">
</span><span class="inline-wrap">当一个对象，没有变量指向它的时候，js<span class="jill"></span>垃圾回收器就会自动 回收这些内存资源。</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">内置对象</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">数组是用来存储数据的，可以存储任意的数据类型。可以将其看作一个容器。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">基本使用</span><span class="inline-wrap">
</span><span class="inline-wrap">数组是<span class="jill"></span>Array<span class="jill"></span>对象，快速用[]快速创建。
向后添加数据
arr[arr.length]=&quot;new 
替换方法
arr.splice(开始索引 , 向后数量 ,&quot;新数组属性&quot;);</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数组的遍历</span><span class="inline-wrap">
</span><span class="inline-wrap">两种方法：
var arr=[1,2,3,4];
专门用于遍历数组的<span class="jill"></span>forEach<span class="jill"></span>方法（不可中途终止遍历）
arr.forEach(function(val,ind){
console.log(&quot;索引=&quot;+ind+&quot;,值=&quot;+val);
});
使用性更广的<span class="jill"></span>for<span class="jill"></span>循环遍历（可中途终止遍历）
for(var i=0;i&lt;arr.length;i++){
console.log(&quot;索引=&quot;+i+&quot;,值=&quot;+arr[i]);
if(i==2){
break;
}
}</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">时间对象<span class="jill"></span>Date</span><span class="inline-wrap">
</span><span class="inline-wrap">获取时间对象
var auto=new Date();//获取当前时间
var din=new Date(&quot;05/20/2020 13:14:00&quot;);//自定义一个时间
时间对象的一些方法
getDate()	以数值返回天（1-31）
getDay()	以数值获取周名（0-6）
getFullYear()	获取四位的年（yyyy）
getHours()	获取小时（0-23）
getMilliseconds()	获取毫秒（0-999）
getMinutes()	获取分（0-59）
getMonth()	获取月（0-11）
getSeconds()	获取秒（0-59）
getTime()	获取时间（从 1970 年 1 月 1 日至今）
console.log(auto.getTime());//获取指定时间的时间戳
var start=Date.now();//获取现在的时间戳。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数学对象<span class="jill"></span>Math</span><span class="inline-wrap">
</span><span class="inline-wrap">Math<span class="jill"></span>对象（数学工具类）
Math.floor(x) 的返回值是 x 下舍入最接近的整数：
Math.ceil(x) 的返回值是 x 上舍入最接近的整数：
Math.round(x) 的返回值是 x 四舍五入为最接近的整数：
Math.random() 返回 0（包括） 至 1（不包括） 之间的随机数：
获取<span class="jill"></span>X<span class="jill"></span>到<span class="jill"></span>Y<span class="jill"></span>的随机整数
Math.round( Math.random()*(y-x)+x )</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">包装类</span><span class="inline-wrap">
</span><span class="inline-wrap">这个内容只需要理解即可，因为它是由底层使用的。
关于包装类：
为什么基本数据类型也可以用<span class="jill"></span>toString<span class="jill"></span>方法？
为什么我们可以基本数据类赋值，却调用不了？
因为当我们用基本数据类型调用一些方法时，底层会自动将基本数据类型转为对象。
a.toString()====
var b=new Number(a);
console.log(b.toString());</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">操作字符的一些方法</span><span class="inline-wrap">
</span><span class="inline-wrap">根据索引获取指定字符<span class="jill"></span>     ut.charAt(1);
连接字符串<span class="jill"></span>           			 ut.concat(&quot;567&quot;,&quot;890&quot;);
截取字符串中的内容<span class="jill"></span>     	 ut.slice(1,-1); [起来<span class="jill"></span>s]
将字符串进行拆分为数组<span class="jill"></span>    name.split(&quot;,&quot;); [cplit]</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">正则表达式</span><span class="inline-wrap">
</span><span class="inline-wrap">test<span class="jill"></span>方法：检查右边的字符是否符合左边的正则
RegExp<span class="jill"></span>对象：动态修改正则表达式， new RegExp(&quot;\b&quot;+cn+&quot;\b&quot;);,会返回一个正则表达式对象</span><span class="inline-wrap">
</span><span class="inline-wrap">str.match(/[a-z]/ig); match<span class="jill"></span>方法将在左边满足的字符，装箱为一个数组。所以需要用全局<span class="jill"></span>g.
(ig<span class="jill"></span>免忽略大小写且进行全局匹配，还有<span class="jill"></span>m<span class="jill"></span>执行多行匹配。)
&quot;&quot;.replace(//,&quot;&quot;)利用正则进行替换字符</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>        （对字符的描述）
           <span class="token punctuation">[</span>abc<span class="token punctuation">]</span>、<span class="token punctuation">[</span><span class="token constant">A</span><span class="token operator">-</span>z0<span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>，
           \w 查找数字、字母、_
           \d  查找数字。
           \s  查找空白字符。
           \b  匹配单词边界。
         （字符量词）
          <span class="token punctuation">{</span>n<span class="token punctuation">,</span>m<span class="token punctuation">}</span>左边一个字符或一个（）组出现n到m次，<span class="token punctuation">{</span>m<span class="token punctuation">}</span>出现m次，<span class="token punctuation">{</span>m<span class="token punctuation">,</span><span class="token punctuation">}</span>出现m次以上。
          <span class="token operator">+</span>至少一个<span class="token operator">===</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span>
          <span class="token operator">*</span>有没有都可以<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span>
          <span class="token operator">?</span>有或没有
         （字符位置）
          <span class="token operator">/</span><span class="token operator">^</span>n<span class="token operator">/</span>前面不能再有字符，
          <span class="token operator">/</span>n$<span class="token operator">/</span>后面不能再有字符
          <span class="token operator">/</span><span class="token operator">^</span>n$<span class="token operator">/</span>完全符合正则表达式，即：只能是str<span class="token operator">=</span><span class="token string">"n"</span><span class="token punctuation">;</span>才满足。</pre></div></code-block></li></ul><h3 class="wolai-block"><span class="inline-wrap">DOM</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事件</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">我们给某个对象绑定事件，我们可以写触发后要执行的代码。
有点击，双击，移入，移出，键盘，滚轮等事件。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">加载事件</span><span class="inline-wrap">
</span><span class="inline-wrap">onload<span class="jill"></span>事件：由于文档加载自上而下的原因，我们需要用到这个事件，以免当我们对文档进行操作时，其对象不存在（还未加载 ）
应用
window.onload=function(){
//当文档加载完成后，会自动触发执行
}</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">焦点事件</span><span class="inline-wrap">
</span><span class="inline-wrap">【焦点事件】
    onfocus<span class="jill"></span>得到焦点
    onblur<span class="jill"></span>失去焦点事件</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">键盘事件</span><span class="inline-wrap">
</span><span class="inline-wrap">键盘事件</span><span class="inline-wrap">
</span><span class="inline-wrap">onkeydown<span class="jill"></span>键按下事件
    onkeyup<span class="jill"></span>键松开事件
    <span class="jill"></span>识别按下是哪个键：
      <span class="jill"></span>在键盘事件触发后，获取传入的参数<span class="jill"></span>event,可以根据<span class="jill"></span>event.keyCode==键码，根据特殊的
      event.altKey,event.shiftKey<span class="jill"></span>等，
      <span class="jill"></span>多键识别：我们可识别特殊键<span class="jill"></span>+<span class="jill"></span>非特殊键
    <span class="jill"></span>取消默认键盘行为
      <span class="jill"></span>键盘事件触发后，return false;时，在输入框时输入将无法正常使用。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">单击/双击事件</span><span class="inline-wrap">
</span><span class="inline-wrap">单击事件
up.onclick=function(){
//要执行的代码
};
双击事件
up.ondbclick=function(){
//要执行的代码
}</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">滚动条事件</span><span class="inline-wrap">
</span><span class="inline-wrap">onscroll <span class="jill"></span>事件：当我们滑动滚动条时触发
使用： info.onscroll=function(){}
获取滚动条的一些信息：
//info.scrollHeight<span class="jill"></span>是总高度
//info.scrollTop<span class="jill"></span>当前滚动条到<span class="jill"></span>top<span class="jill"></span>的长度
//info.clientHeight<span class="jill"></span>可见页面高度
扩展：
组件可用性：disabled=true|false;</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">滚轮事件</span><span class="inline-wrap">
</span><span class="inline-wrap">滚轮事件</span><span class="inline-wrap">
</span><span class="inline-wrap">box.onmousewheel = function(event) {//滚动触发
  event = event || window.event;
  if (event.wheelDelta &gt; 0 || event.detail &lt; 0) {//判断是否是下滚动且兼容
    box.style.height = box.clientHeight - 10 + &quot;px&quot;;
  } else {
    box.style.height = box.clientHeight + 10 + &quot;px&quot;;
}</span><span class="inline-wrap">
</span><span class="inline-wrap">  event.preventDefault &amp;&amp; event.preventDefault(); //解决连带滚动条滚动问题,&amp;&amp;当可用时执行
  return false; //取消默认行为（滚动默认连动总页面滚动）
}
//解决滚轮事件浏览器兼容问题，如果是火狐，它是不支持<span class="jill"></span>onmousewheel<span class="jill"></span>事件的，
bind(box, &quot;DOMMouseScroll&quot;, box.onmousewheel);
function bind(obj, eventStr, callback) { //事件监听兼容函数
  if (obj.addEventListener) {
    obj.addEventListener(eventStr, callback, false);
  } else {
    obj.attachEvent(&quot;on&quot; + eventStr, function() {
      callback.call(obj);
    });
  }
}</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">节点</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">获取节点</span><span class="inline-wrap">
</span><span class="inline-wrap">【获取节点】
（document）
document.getElementById(&quot;bt&quot;);//根据<span class="jill"></span>Id<span class="jill"></span>获取节点
getElementsByTagName(&quot;li&quot;);//演示根据标签名获取组属性
document.getElementsByName(&quot;user&quot;);//演示根据<span class="jill"></span>name<span class="jill"></span>的属性获取组属性
var bufu=document.querySelectorAll(&quot;#imgbox&quot;); //根据<span class="jill"></span>css<span class="jill"></span>选择器获取组节点
【获取关系节点】
fu.children;//获取全部子属性节点
down.parentNode;//获取父节点
down.previousElementSibling;//获取前一个兄弟节点
down.nextSibling;//获取后一个兄弟节点</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">创建节点</span><span class="inline-wrap">
</span><span class="inline-wrap">【创建节点与节点关系】
var but=document.createElement(&quot;button&quot;);//创建一个属性节点
var btext=document.createTextNode(&quot;最后一张&quot;); //创建一个文本节点（可在父节点用<span class="jill"></span>innerHTML<span class="jill"></span>代替）
but.appendChild(btext);//将新节点插入指定节点下</span><span class="inline-wrap">
</span><span class="inline-wrap">bufu.insertBefore(but,down);//将新的节点插入指定的子节点之前。
bufu.replaceChild(but,down);//将新节点代替旧节点
but.parentNode.removeChild(but);//删除子节点</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读取节点</span><span class="inline-wrap">
</span><span class="inline-wrap">读取节点的属性与内部<span class="jill"></span>HTML<span class="jill"></span>代码</span><span class="inline-wrap">
</span><span class="inline-wrap">bt.value;//读节点属性。
（class<span class="jill"></span>属性是保留字，需要.className<span class="jill"></span>去读取）
bt.innerHTML;//读内部<span class="jill"></span>HTML<span class="jill"></span>代码<span class="jill"></span> 
bt.innerText;//获取除标签外的全部内部文本</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">应用</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修改样式</span><span class="inline-wrap">
</span><span class="inline-wrap">为属性设置内部样式属性
obj.style.backgroundColor=&quot;red&quot;;
除此，我们还可以通过修改<span class="jill"></span>Class<span class="jill"></span>值来添加或删除一组样式。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读取样式</span><span class="inline-wrap">
</span><span class="inline-wrap">利用下面的方法可以读取现在正在显示的样式</span><span class="inline-wrap">
</span><span class="inline-wrap">function getStyle(obj,name){//读取现在的样式属性值
if(window.getComputedStyle){
  //大部分浏览器支持
  return getComputedStyle(obj,null)[name];
}else{
  //只有<span class="jill"></span>IE8<span class="jill"></span>支持
  return obj.currentStyle[name];
}
}</span></li></ul></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">捕获与冒泡</span><span class="inline-wrap">
</span><span class="inline-wrap">如果以父子关系依次相关联的，当子事件被触发时，以<span class="jill"></span>W3C<span class="jill"></span>的标准，分为从<span class="jill"></span>document<span class="jill"></span>到目标的捕获阶段，再到从目标向外的冒泡阶段。如果我们想在捕获时执行，需要在事件监听器
obj.addEventListener(eventStr,callback,false);</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事件的冒泡</span><span class="inline-wrap">
</span><span class="inline-wrap">子元素事件被触发会自动触发相同事件的父元素。</span><span class="inline-wrap">
</span><span class="inline-wrap">取消冒泡
var maot = document.getElementById(&quot;maoTest&quot;); //取消冒泡
    maot.onmousemove = function(event) {
        event.cancelBubble = true; //隔板生效
    }</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事件的委派</span><span class="inline-wrap">
</span><span class="inline-wrap">每个事件被触发后执行的函数都可以接收一个参数，他封装了一些信息，如由于事件的冒泡，我们不确定是谁触发的自己，这时参数对象有一个<span class="jill"></span>target<span class="jill"></span>属性，可以得到最先被触发的那个对象。</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自定义方法</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">拖拽函数</span><span class="inline-wrap">
</span><span class="inline-wrap">使用方法：只需传入要移动对象即可。</span><span class="inline-wrap">
</span><span class="inline-wrap">function Tuo(box){ //拖拽函数
//给<span class="jill"></span>box<span class="jill"></span>添加一个鼠标按下事件
box.onmousedown=function(event){
//获取点击时在<span class="jill"></span>box<span class="jill"></span>中的相对位置<span class="jill"></span>x2,y2
var  x2=event.clientX-box.offsetLeft;//
var  y2=event.clientY-box.offsetTop;
//给<span class="jill"></span>document<span class="jill"></span>添加一个拖拽事件
document.onmousemove=function(event){
//将传进来的<span class="jill"></span>event<span class="jill"></span>参数加强兼容性
event=event || window.event;
//获取鼠标在<span class="jill"></span>document<span class="jill"></span>中的位置
var  x=event.clientX;
var  y=event.clientY;
//修改<span class="jill"></span>box<span class="jill"></span>中的<span class="jill"></span>top<span class="jill"></span>与<span class="jill"></span>left<span class="jill"></span>属性
box.style.top=y-y2+&quot;px&quot;;
box.style.left=x-x2+&quot;px&quot;;</span><span class="inline-wrap">
</span><span class="inline-wrap">}
}</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>  <span class="token punctuation">}</span>
  <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onmouseup</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//当松下后，关闭移动与松下事件</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">onmousemove</span><span class="token operator">=</span><span class="token keyword null nil">null</span><span class="token punctuation">;</span>
      <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">onmouseup</span><span class="token operator">=</span><span class="token keyword null nil">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//解决全选后拖拽不了的问题</span>
  
  </pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">方向键移动函数</span><span class="inline-wrap">
</span><span class="inline-wrap">box ：是要移动的对象
a ：是物体移动的速度</span><span class="inline-wrap">
</span><span class="inline-wrap">function boxmove(box, a){
var fan;//移动的方向
//当按下一个键时，改变方向变量<span class="jill"></span>fan<span class="jill"></span>的值。松开时设置为空。
//即我们按下时就朝着设置好的方向移动，松开后没有移动方向。
document.onkeydown=function(event){
fan=event.keyCode;
document.onkeyup=function(){
fan=null;
}</span><span class="inline-wrap">
</span><span class="inline-wrap">}</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>  <span class="token punctuation">}</span>
  
  <span class="token keyword">var</span>  yidon<span class="token operator">=</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword control-flow">switch</span><span class="token punctuation">(</span>fan<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token number">37</span><span class="token operator">:</span>
        box<span class="token punctuation">.</span><span class="token property-access">style</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token operator">=</span>box<span class="token punctuation">.</span><span class="token property-access">offsetLeft</span><span class="token operator">-</span>a<span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token number">38</span><span class="token operator">:</span>
        box<span class="token punctuation">.</span><span class="token property-access">style</span><span class="token punctuation">.</span><span class="token property-access">top</span><span class="token operator">=</span>box<span class="token punctuation">.</span><span class="token property-access">offsetTop</span><span class="token operator">-</span>a<span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
        
      <span class="token keyword">case</span> <span class="token number">39</span><span class="token operator">:</span>
        box<span class="token punctuation">.</span><span class="token property-access">style</span><span class="token punctuation">.</span><span class="token property-access">left</span><span class="token operator">=</span>box<span class="token punctuation">.</span><span class="token property-access">offsetLeft</span><span class="token operator">+</span>a<span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token number">40</span><span class="token operator">:</span>
        box<span class="token punctuation">.</span><span class="token property-access">style</span><span class="token punctuation">.</span><span class="token property-access">top</span><span class="token operator">=</span>box<span class="token punctuation">.</span><span class="token property-access">offsetTop</span><span class="token operator">+</span>a<span class="token operator">+</span><span class="token string">"px"</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>            
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></div></code-block></li></ul></li></ul><h3 class="wolai-block"><span class="inline-wrap">BOM</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识<span class="jill"></span>BOM</span><span class="inline-wrap">
</span><span class="inline-wrap">浏览器对象模型<span class="jill"></span>BOM</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Navigator</span><span class="inline-wrap">
</span><span class="inline-wrap">【Navigator】
--获取浏览的信息，识别不同浏览器
var  ua=navigator.userAgent;
if(/firefox/i.test(ua)){
  alert(&quot;你是火狐&quot;);
}else if(/chrome/i.test(ua)){
  alert(&quot;你是谷歌&quot;);
}else if(/msie/i.test(ua)){
  alert(&quot;你是<span class="jill"></span>IE&quot;);
}else if(&quot;ActiveXObject&quot; in window){
  alert(&quot;你是<span class="jill"></span>IE11，枪毙了你<span class="jill"></span>~&quot;);
}</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Location</span><span class="inline-wrap">
</span><span class="inline-wrap">【Location】
--代表浏览的地址栏
//执行后会跳转到指定链接上
location.assign(&quot;</span><span class="inline-wrap"><a href="http://www.baidu.com"><span>http://www.baidu.com</span></a></span><span class="inline-wrap">&quot;);</span><span class="inline-wrap">
</span><span class="inline-wrap">//执行后会清除缓存
location.reload(true);</span><span class="inline-wrap">
</span><span class="inline-wrap">//执行后会替换当前，且不可逆。
location.replace(&quot;</span><span class="inline-wrap"><a href="http://www.baidu.com"><span>http://www.baidu.com</span></a></span><span class="inline-wrap">&quot;);</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">History</span><span class="inline-wrap">
</span><span class="inline-wrap">【History】
--当前容器的历史记录
history.back();//当前窗口的上一个页面
history.go(-2);//跳转到前第二个页面
history.forward();//当前窗口的下一个页面</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">screen</span><span class="inline-wrap">
</span><span class="inline-wrap">【screen】
--获取显示器的相关信息</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">定时器&amp;超时调用</span><span class="inline-wrap">
</span><span class="inline-wrap">定时器
setInterval(function(){</span><span class="inline-wrap">
</span><span class="inline-wrap">},&lt;循环调用时间&gt;);</span><span class="inline-wrap">
</span><span class="inline-wrap">clearInterval( );//关闭指定的定时器
超时调用
setTimeout（function(){</span><span class="inline-wrap">
</span><span class="inline-wrap">},&lt;调用时间&gt;);
clearTimeou //关闭指定的超时调用</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自定义的方法</span><span class="inline-wrap">
</span><span class="inline-wrap">/*
1、动画函数
obj：目标属性
speed：改变的速度
target:改变的幅度
type:top\left\width\height
fun:回调函数，动画执行完时调用</span><span class="inline-wrap">
</span><span class="inline-wrap">*/
function move(obj, speed,target,type,fun){
console.log(&quot;你调用了<span class="jill"></span>jsTools<span class="jill"></span>中的<span class="jill"></span>move<span class="jill"></span>动画函数<span class="jill"></span>~&quot;);
function  getStyle(obj , name){//根据样式名获取样式值
if(window.getComputedStyle){
return getComputedStyle(obj,null)[name];
}else{
return obj.currentStyle[name];
}
}
//函数主体
clearInterval(obj.ding);
if(parseInt(getStyle(obj,type))&gt;target){
speed=-speed;
}
obj.ding=setInterval(function(){
var oldValue=parseInt(getStyle(obj,type));
var newValue=oldValue+speed;
if((speed&lt;0 &amp;&amp; newValue &lt; target ) ||( speed&gt;0 &amp;&amp; newValue &gt; target) ){
newValue=target;
obj.style[type]=newValue+&quot;px&quot;;
clearInterval(obj.ding);
fun ?fun(): console.log(&quot;未传入回调函数&quot;);//执行回调函数
}else{
obj.style[type]=newValue+&quot;px&quot;;
}</span><span class="inline-wrap">
</span><span class="inline-wrap">}
/*
2、添加或删除指定<span class="jill"></span>Class<span class="jill"></span>值
obj：目标属性
cn:是要添加或移除的<span class="jill"></span>Class<span class="jill"></span>值
*/
function hasClass(obj,cn){//有添加，无删除<span class="jill"></span>Class<span class="jill"></span>指定值
var ze=new RegExp(&quot;\b&quot;+cn+&quot;\b&quot;);
if(ze.test(obj.className)){
obj.className=obj.className.replace(ze,&quot;&quot;);
console.log(&quot;已替换&quot;);
}else{
obj.className+=&quot; &quot;+cn;
console.log(&quot;已添加&quot;);
}
}
function AddClass(obj,cn){//没有添加<span class="jill"></span> 
var ze=new RegExp(&quot;\b&quot;+cn+&quot;\b&quot;);
if(! ze.test(obj.className)){
obj.className+=&quot; &quot;+cn;
}
}
function RemoveClass(obj,cn){//有移除
var ze=new RegExp(&quot;\b&quot;+cn+&quot;\b&quot;);
obj.className=obj.className.replace(ze,&quot;&quot;);
}</span><span class="inline-wrap">
</span><span class="inline-wrap">/*
3、二级菜单伸缩动画函数
使用说明：给具有指定结构的二级菜单栏添加伸缩动画效果
&lt;div id=&quot;my_menu&quot; class=&quot;sdmenu&quot;&gt;
&lt;div class=&quot;collapsed&quot;&gt;
</span><span class="inline-wrap">在线工具</span><span class="inline-wrap">图像优化</span><span class="inline-wrap">
...
</span><span class="inline-wrap">支持我们</span><span class="inline-wrap">图像优化</span><span class="inline-wrap">收藏夹图标</span><span class="inline-wrap">
....
</span><span class="inline-wrap">
</span><span class="inline-wrap"><i>/
function mocc(boxId){
var box=document.getElementById(boxId);
//获取二级菜单主体下的<span class="jill"></span>span
var title=box.getElementsByTagName(&quot;span&quot;);
var index;
//遍历<span class="jill"></span>span
for(var i=0;i&lt;title.length;i++){
title[i].index=i;
title[i].ofno=false;
//为每个<span class="jill"></span>span<span class="jill"></span>绑定一个单击响应函数
title[i].onclick=function(){
//得到当前<span class="jill"></span>span<span class="jill"></span>的父节点,与其下一个兄弟
var Tparent=this.parentNode;
var Tsibling=this.nextElementSibling;
if(Tsibling){
//分别得到展开前后的动态值
var init=Tparent.querySelector(&quot;span&quot;).offsetHeight;
var end=Tparent.querySelectorAll(&quot;a&quot;).length</i></span><span class="inline-wrap">(Tsibling.offsetHeight)+init;
//根据现在的状态，给等下要操作的目标长度赋值 后修改操作后的状态
var mo=this.ofno ? init :end;
this.ofno ? (this.ofno=false) : (this.ofno=true);
move(Tparent,6, mo,&quot;height&quot;,function(){
});
}</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>          <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          </pre></div></code-block><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span></pre></div></code-block></li></ul></li></ul><h2 class="wolai-block"><span class="inline-wrap">高级</span></h2><h3 class="wolai-block"><span class="inline-wrap">对基础知识的深入了解</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">函数参数</span><span class="inline-wrap">
</span><span class="inline-wrap">我们给函数传入参数时，就相当于在函数作用域中声明了一个变量。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">资源的回收</span><span class="inline-wrap">
</span><span class="inline-wrap">自动释放：生命周期完后
回收:没有变量指定这个内存地址后，这块内存就会被回收器回收。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">[]在对象中的应用</span><span class="inline-wrap">
</span><span class="inline-wrap">var obj={
&quot;a-b&quot;:123,
&quot;123&quot;:&quot;ab&quot;
 }
console.log(obj[&quot;a-b&quot;]); //特殊属性名时
var  name=&quot;a-b&quot;;//属性名不确定时
console.log(obj[name]);</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回调函数</span><span class="inline-wrap">
</span><span class="inline-wrap">什么是回调函数？
---你定义了，没有调用，但最后执行了。
比如：事件 、定时器</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">IIFE</span><span class="inline-wrap">
</span><span class="inline-wrap">IIFE ——立即执行函数的作用
---不会污染全局命名空间，隐藏实现。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">isAdd<span class="jill"></span>分号?</span><span class="inline-wrap">
</span><span class="inline-wrap">关于加不加分号问题
---小括号、中括号 前不加就会报错。
var a=3
(function(){alert(123)})()
或
var a=3
[1,2]forE....</span></li></ul><h3 class="wolai-block"><span class="inline-wrap">高级部分</span></h3><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原型对象</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">再认识</span><span class="inline-wrap">
</span><span class="inline-wrap">函数的原型对象默认指向一个空对象，里面默认有下面这两个属性。
            constructor //指向自己<span class="jill"></span>this
            </span><span class="inline-wrap"><b>proto</b></span><span class="inline-wrap"> //原型的原型对象</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">显式原型与隐式原型</span><span class="inline-wrap">
</span><span class="inline-wrap">显式原型对象与隐式原型对象
函数<span class="jill"></span>prototype 显式原型对象====对应实例的 </span><span class="inline-wrap"><b>proto</b></span><span class="inline-wrap"> 隐式原型对象</span><span class="inline-wrap">
</span><span class="inline-wrap">          <span class="jill"></span>创建函数时，Fn.prototype={}
          <span class="jill"></span>创建实例时，this.</span><span class="inline-wrap"><b>proto</b></span><span class="inline-wrap">=Fn.prototype</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原型链</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">原型链的继承</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">变量提升与函数提升</span><span class="inline-wrap">
</span><span class="inline-wrap">*变量提升与函数提升
变量提升，执行之前先声明，但未赋值
函数提升，在语句之前已声明，完整存在</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>    理解：在变量执行之前，就可以访问到了，但它的值是<span class="token keyword nil">undefined</span>。在函数执行之前，就可以调用到了。因为存到了上下文中栈中了。
    且先执行变量提升再执行函数提升！！
    注意：就算是<span class="token keyword control-flow">if</span>语句中的变量，也是会自动进行变量提升的。</pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">作用域</span><span class="inline-wrap">
</span><span class="inline-wrap">*作用域 ——迷惑型题目
题<span class="jill"></span>1：
var a=4;
function fun1(){
console.log(a);
}
function fun2(){
var a=6;
fun1();
}
fun2();
结果： 4 ，是根据自己身所在位置进行查找的，而不是根据关系查找。
题<span class="jill"></span>2
var obj={
tet:function (){
console.log(tet);
}
}
obj.tet();
结果是：报错，找不到
总结：是根据上下文栈块逐层查找的。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">执行上下文</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">分类</span><span class="inline-wrap">
</span><span class="inline-wrap">JavaScript 中有三种执行上下文类型。
全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">执行上下文栈</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">执行上下文栈.jpg</span></li></ul></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">闭包</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">产生的条件</span><span class="inline-wrap">
</span><span class="inline-wrap">函数内嵌套有函数，
内函数引用了外函数的属性（变量或函数),
并且外部函数被调用执行;</span><span class="inline-wrap">
</span><span class="inline-wrap">(function Pro(){
var a=Math.random();
window.mm=function (x,y){
return Math.floor(y-a*(y-x));
}
})()//外部函数调用</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">自定义<span class="jill"></span>JS<span class="jill"></span>模块</span><span class="inline-wrap">
</span><span class="inline-wrap">js<span class="jill"></span>自定义模块
将代码封装在一个<span class="jill"></span>JS<span class="jill"></span>文件中，有特定功能。向外暴露一些行为函数。
1、私有数据
2、操作数据的函数
3、向外暴露对象（给外部使用的方法）</span><span class="inline-wrap">
</span><span class="inline-wrap">var myModule = (function(){
var var1 = 1;
var var2 = 2;
function func1(){
...
}
function func2(){
...
}
return {
func1: func1,
func2: func2
};
})();</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">终极面试题</span><span class="inline-wrap">
</span><span class="inline-wrap">终极面试题</span><span class="inline-wrap">
</span><span class="inline-wrap">function fun(n,o){
console.log(o);
return {
fun:function (m) {
return fun(m, n);
}
}
}
var a=fun(0).fun(1).fun(2).fun(3);</span><span class="inline-wrap">
</span><span class="inline-wrap">解析：a=fun(0) 时，它的返回值中含有闭光，值为<span class="jill"></span>0
...fun(1) 时，它的返回值中含有闭光，值为<span class="jill"></span>1
.....f</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">内存的溢出与泄露</span><span class="inline-wrap">
</span><span class="inline-wrap">*内存溢出与内存泄露
你需要的内存大于剩余的内存空间，就会导致内存溢出。从而报错。
内存泄露：不合理地占用内存资源，而不及时地释放
，如，定时器、函数中变量的错误声明为全局变量等，都会导致内存泄露从而使内存溢出。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">借用构造函数</span><span class="inline-wrap">
</span><span class="inline-wrap">构造函数借用构造函数：得到属性
function Fun1(age){
this.age=age;
}
function Fun2(name,age){
this.name=name;
Fun1.call(this,age);//开始借用
}</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">单线程与多线程</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">*单线程与多线程
有的程序是单进程有的是多进程的，而多进程数据一般是不共享的，且每一个进程可能有多个线程。
JS<span class="jill"></span>是单线程的：警告框可以暂停主线程的执行，如果是多线程会带来很复杂的同步问题。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Web worker<span class="jill"></span>多线程技术</span><span class="inline-wrap">
</span><span class="inline-wrap">*Web Worker
Web Worker，作为<span class="jill"></span>JS<span class="jill"></span>中的多线程技术，主要用来处理耗时较长的程序。</span><span class="inline-wrap">
</span><span class="inline-wrap">主线程（老板）---调用*.js<span class="jill"></span>文件
var wo=new Worker(&quot;fine.js&quot;);
wo.postMessage(1);//向分线程发送数据
wo.onmessage=function (e){
//接收分线程传过来的数据
console.log(e.data);
}
分线程（工人）---* .js
var onmessage=function(event){
var jout=++(event.data); //接收主线程传过来的数据
postMessage(jout );//向主线程发送数据
}</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回调队列</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">认识</span><span class="inline-wrap">
</span><span class="inline-wrap">回调队列</span><span class="inline-wrap">
</span><span class="inline-wrap"> 	初始化代码执行完后，才会执行回调代码，而执行回调代码时先将它们添加到对应的模块中，当条件满足时，如点击了，定时器的时间到了，就会将其添加到回调队列后面进行排队,然后先进先出。</span><span class="inline-wrap">
</span><span class="inline-wrap">*Web Worker</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre>  <span class="token keyword">var</span> yfd<span class="token operator">=</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">"yfd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  yfd<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onclick</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//点击后，会在后面添加到回调队列中。</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"点击事件:进入回调队列并执行了~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"外部定时器已开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"内部定时器结束了"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会添加对应模块中，3秒条件满足后，会在后面添加到回调队列中。</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"外部定时器已结束,此时如果你不点击回调队列中没有东西。但已新添加了一个定时器，等下不管你有没有点击，3秒后都会添加到事件队列中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"初始化执行完了。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">图解</span></li></ul></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><i>XMind: ZEN - Trial Version</i></span></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>