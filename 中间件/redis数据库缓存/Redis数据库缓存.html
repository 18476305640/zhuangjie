<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>Redis数据库缓存 - wolai 笔记</title><link rel="shortcut icon" href="media/redis-4-1175103_1.webp"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon icon-image" style="background-image: url(&quot;media/redis-4-1175103.webp&quot;)"></div></div><div data-title="Redis数据库缓存" class="main-title"></div></div></header><article><h3 class="wolai-block"><span class="inline-wrap">-介绍</span></h3><h3 class="wolai-block"><span class="inline-wrap">[_1_] Redis<span class="jill"></span>安装</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">基本环境准备</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment">#安装基本环境</span>
yum <span class="token function">install</span> gcc <span class="token operator">&amp;</span> gcc -v
yum -y <span class="token function">install</span> gcc-c++ <span class="token operator">&amp;</span> g++ -v
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">安装<span class="jill"></span>Redis (安装后密码是<span class="jill"></span>3333)</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token function">wget</span> http://download.redis.io/releases/redis-5.0.7.tar.gz
<span class="token function">tar</span> -zvxf redis-5.0.7.tar.gz
<span class="token comment">#编译与安装</span>
<span class="token builtin class-name">cd</span> redis-5.0.7
<span class="token function">make</span>
<span class="token builtin class-name">cd</span> src
<span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span>/usr/local/redis
<span class="token comment">#移动配置文件到安装目录下</span>
<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/
<span class="token function">mkdir</span> /usr/local/redis/etc
<span class="token function">mv</span> redis.conf /usr/local/redis/etc
<span class="token comment">#配置redis为后台启动</span>
<span class="token comment">#将daemonize no 改成daemonize yes</span>
<span class="token function">sed</span> -i <span class="token string">'/daemonize/s/daemonize no/daemonize yes/g'</span> /usr/local/redis/etc/redis.conf
<span class="token comment">#将redis加入到开机启动</span>
<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">>></span>/etc/rc.local</span>
#开机启动redis
/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf
EOF</span>
redis-server /usr/local/redis/etc/redis.conf 
<span class="token comment">#将redis-cli,redis-server拷贝到bin下，让redis-cli指令可以在任意目录下直接使用</span>
<span class="token function">cp</span> /usr/local/redis/bin/redis-server /usr/local/bin/
<span class="token function">cp</span> /usr/local/redis/bin/redis-cli /usr/local/bin/
<span class="token comment">#设置密码</span>
redis-cli
config get requirepass
config <span class="token builtin class-name">set</span> requirepass <span class="token number">3333</span>
<span class="token builtin class-name">exit</span>
<span class="token comment">#登录测试</span>
redis-cli
auth <span class="token number">3333</span>
<span class="token comment">#其它操作</span>

</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+ 基本命令</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>redis-cli  <span class="token comment">#进入</span>
auth 密码  <span class="token comment">#认证</span>
<span class="token keyword">select</span> <span class="token number">1</span> <span class="token comment">#进入1数据库</span>
<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token comment">#设置值</span>
get <span class="token operator">&lt;</span>key<span class="token operator">></span>  <span class="token comment">#获取值</span>
expire <span class="token operator">&lt;</span>key<span class="token operator">></span> 过期时间单元为秒  <span class="token comment">#设置过期时间</span>
ttl <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token comment">#查看过期时间</span>
keys * <span class="token comment">#查看所以</span>
move <span class="token operator">&lt;</span>key<span class="token operator">></span>  <span class="token operator">&lt;</span>db<span class="token operator">></span> <span class="token comment">#将指定的记录的移动到指定库</span>
exists <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token comment">#查看是否存在指定的key记录</span>
<span class="token builtin class-name">type</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token comment">#查看指定key记录的类型</span>

</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">键（Key）命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们知道 Redis 是 key-value 型数据库，使用 key 对 value 进行存储，因此，键（Key）命令是 Redis 中经常使用的一类命令。常用的键命令如下所示：  </span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 158px"><span class="inline-wrap">命令</span></th><th style="width: 635px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/del.html"><span>DEL</span></a></span></td><td><span class="inline-wrap">若键存在的情况下，该命令用于删除键</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/dump.html"><span>DUMP</span></a></span></td><td><span class="inline-wrap">用于序列化给定 key ，并返回被序列化的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/exists.html"><span>EXISTS</span></a></span></td><td><span class="inline-wrap">用于检查键是否存在，若存在则返回 1，否则返回 0</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/expire.html"><span>EXPIRE</span></a></span></td><td><span class="inline-wrap">设置 key 的过期时间，以秒为单位</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/expireat.html"><span>EXPIREAT</span></a></span></td><td><span class="inline-wrap">该命令与 EXPIRE 相似，用于为 key 设置过期时间，不同在于，它的时间参数值采用的是时间戳格式。</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/keys.html"><span>KEYS</span></a></span></td><td><span class="inline-wrap">此命令用于查找与指定<span class="jill"></span> pattern 匹配的 key</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/move.html"><span>MOVE</span></a></span></td><td><span class="inline-wrap">将当前数据库中的 key 移动至指定的数据库中（默认存储为 0 库，可选 1-15<span class="jill"></span>中的任意库）</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/persist.html"><span>PERSIST</span></a></span></td><td><span class="inline-wrap">该命令用于删除 key 的过期时间，然后 key 将一直存在，不会过期</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/pexpire.html"><span>PEXPIRE</span></a></span></td><td><span class="inline-wrap">设置 key 的过期，以毫秒为单位</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/randomkey.html"><span>RANDOMKEY</span></a></span></td><td><span class="inline-wrap">从当前数据库中随机返回一个 key</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/rename.html"><span>RENAME</span></a></span></td><td><span class="inline-wrap">修改 key 的名称</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/scan.html"><span>SCAN</span></a></span></td><td><span class="inline-wrap">基于游标的迭代器，用于迭代数据库中存在的所有键，cursor 指的是迭代游标</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/ttl.html"><span>TTL</span></a></span></td><td><span class="inline-wrap">用于检查 key 还剩多长时间过期，以秒为单位</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/type.html"><span>TYPE</span></a></span></td><td><span class="inline-wrap">该命令用于获取 value 的数据类型。</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">Hash 命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Hash（哈希散列）是 Redis 基本数据类型之一，它以字符串映射表的形式来进行存储。Hash 特别适合用于存储对象。常用的命令如下所示：  </span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 158px"><span class="inline-wrap">命令</span></th><th style="width: 604px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hdel.html"><span>HDEL</span></a></span></td><td><span class="inline-wrap">用于删除一个或多个哈希表字段</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hexists.html"><span>HEXISTS</span></a></span></td><td><span class="inline-wrap">用于确定哈希字段是否存在</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hget.html"><span>HGET</span></a></span></td><td><span class="inline-wrap">获取存储在 key 中的哈希字段的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hgetall.html"><span>HGETALL</span></a></span></td><td><span class="inline-wrap">获取存储在 key 中的所有哈希字段值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hincrby.html"><span>HINCRBY</span></a></span></td><td><span class="inline-wrap">为存储在 key 中的哈希表指定字段做整数增量运算</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hkeys.html"><span>HKEYS</span></a></span></td><td><span class="inline-wrap">获取存储在 key 中的哈希表的所有字段</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hlen.html"><span>HLEN</span></a></span></td><td><span class="inline-wrap">获取存储在 key 中的哈希表的字段数量</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hset.html"><span>HSET</span></a></span></td><td><span class="inline-wrap">用于设置存储在 key 中的哈希表字段的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/hvals.html"><span>HVALS</span></a></span></td><td><span class="inline-wrap">用于获取哈希表中的所有值</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">String 命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Strings（字符串）结构是 Redis 的基本数据类型之一，我们可以通过相关字符串命令对其进行操作，比如设置、检索、删除等等。字符串类型有诸多的应用场景，比如微博粉丝的关注与取消等。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">下面介绍了 Redis 中常营的字符串命令：  </span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 158px"><span class="inline-wrap">命令</span></th><th style="width: 618px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/append.html"><span>APPEND</span></a></span></td><td><span class="inline-wrap">该命令将 value 追加到 key 所存储值的末尾</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/bitcount.html"><span>BITCOUNT</span></a></span></td><td><span class="inline-wrap">该命令用于计算字符串中，被设置为 1 的比特位的数量。</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/decr.html"><span>DECR</span></a></span></td><td><span class="inline-wrap">将 key 所存储的整数值减<span class="jill"></span> 1</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/decrby.html"><span>DECRBY</span></a></span></td><td><span class="inline-wrap">将 key 所储存的值减去给定的递减值（decrement）</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/get.html"><span>GET</span></a></span></td><td><span class="inline-wrap">用于检索指定键的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/getbit.html"><span>GETBIT</span></a></span></td><td><span class="inline-wrap">对 key 所存储的字符串值，获取其指定偏移量上的位（bit）</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/getrange.html"><span>GETRANGE</span></a></span></td><td><span class="inline-wrap">返回 key 中字符串值的子字符</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/getset.html"><span>GETSET</span></a></span></td><td><span class="inline-wrap">将给定 key 的值设置为 value，并返回 key 的旧值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/incr.html"><span>INCR</span></a></span></td><td><span class="inline-wrap">将 key 所存储的整数值加 1</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/incrby.html"><span>INCRBY</span></a></span></td><td><span class="inline-wrap">将 key 所储存的值加上给定的递增值（increment）</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/incrbyfloat.html"><span>INCRBYFLOAT</span></a></span></td><td><span class="inline-wrap">将 key 所储存的值加上指定的浮点递增值（increment）</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/mget.html"><span>MGET</span></a></span></td><td><span class="inline-wrap">一次性获取一个或多个<span class="jill"></span> key 所存储的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/mset.html"><span>MSET</span></a></span></td><td><span class="inline-wrap">该命令允许同时设置多个键值对</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/msetnx.html"><span>MSETNX</span></a></span></td><td><span class="inline-wrap">当指定的 key 都不存在时，用于设置多个键值对</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/set.html"><span>SET</span></a></span></td><td><span class="inline-wrap">用于设定指定键的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/setbit.html"><span>SETBIT</span></a></span></td><td><span class="inline-wrap">对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/setex.html"><span>SETEX</span></a></span></td><td><span class="inline-wrap">将值 value 存储到 key<span class="jill"></span>中 ，并将 key 的过期时间设为 seconds (以秒为单位)</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/strlen.html"><span>STRLEN</span></a></span></td><td><span class="inline-wrap">返回 key 所储存的字符串值的长度</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/setnx.html"><span>SETNX</span></a></span></td><td><span class="inline-wrap">当 key 不存在时设置 key 的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/setrange.html"><span>SETRANGE</span></a></span></td><td><span class="inline-wrap">从偏移量 offset <span class="jill"></span>开始，使用指定的 value 覆盖的 key 所存储的部分字符串值</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">List 命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">List 是 Redis 中最常用数据类型之一。Redis 提供了诸多用于操作列表类型的命令，通过这些命令你可以实现将一个元素添加到列表的头部，或者尾部等诸多操作。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">List 常用的命令如下所示：  </span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 166px"><span class="inline-wrap">命令</span></th><th style="width: 629px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/blpop.html"><span>BLPOP</span></a></span></td><td><span class="inline-wrap">用于删除并返回列表中的第一个元素（头部操作），如果列表中没有元素，就会发生阻塞，直到列表等待超时或发现可弹出元素为止</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/brpop.html"><span>BRPOP</span></a></span></td><td><span class="inline-wrap">用于删除并返回列表中的最后一个元素（尾部操作），如果列表中没有元素，就会发生阻塞，直到列表等待超时或发现可弹出元素为止</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/brpoplpush.html"><span>BRPOPLPUSH</span></a></span></td><td><span class="inline-wrap">从列表中取出最后一个元素，并插入到另一个列表的头部。如果列表中没有元素，就会发生阻塞，直到等待超时或发现可弹出元素时为止</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lindex_command.html"><span>LINDEX</span></a></span></td><td><span class="inline-wrap">通过索引获取列表中的元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/linsert.html"><span>LINSERT</span></a></span></td><td><span class="inline-wrap">指定列表中一个元素在它之前或之后插入另外一个元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/llen.html"><span>LLEN</span></a></span></td><td><span class="inline-wrap">用于获取列表的长度</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lpop.html"><span>LPOP</span></a></span></td><td><span class="inline-wrap">从列表的头部弹出元素，默认为第一个元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lpush.html"><span>LPUSH</span></a></span></td><td><span class="inline-wrap">在列表头部插入一个或者多个值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lpushx.html"><span>LPUSHX</span></a></span></td><td><span class="inline-wrap">当储存列表的 key 存在时，用于将值插入到列表头部</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lrange.html"><span>LRANGE</span></a></span></td><td><span class="inline-wrap">获取列表指定范围内的元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lrem.html"><span>LREM</span></a></span></td><td><span class="inline-wrap">表示从列表中删除元素与 value 相等的元素。count 表示删除的数量，为 0 表示全部移除</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/lset.html"><span>LSET</span></a></span></td><td><span class="inline-wrap">表示通过其索引设置列表中元素的值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/ltrim.html"><span>LTRIM</span></a></span></td><td><span class="inline-wrap">保留列表中指定范围内的元素值</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">Set 命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis set 数据类型由键值对组成，这些键值对具有无序、唯一的性质，这与 Python 的 set 相似。当集合中最后一个元素被移除之后，该数据结构也会被自动删除，内存也同样会被收回。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于 set 集合可以实现去重，因此它有很多适用场景，比如用户抽奖活动，使用 set 集合可以保证同一用户不被第二次选中。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Redis set 常用的命令如下所示：</span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 166px"><span class="inline-wrap">命令</span></th><th style="width: 631px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sadd.html"><span>SADD</span></a></span></td><td><span class="inline-wrap">向集合中添加一个或者多个元素，并且自动去重</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/scard.html"><span>SCARD</span></a></span></td><td><span class="inline-wrap">返回集合中元素的个数</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sdiff.html"><span>SDIFF</span></a></span></td><td><span class="inline-wrap">求两个或对多个集合的差集</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sdiffstore.html"><span>SDIFFSTORE</span></a></span></td><td><span class="inline-wrap">求两个集合或多个集合的差集，并将结果保存到指定的集合(key)中</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sinter.html"><span>SINTER</span></a></span></td><td><span class="inline-wrap">求两个或多个集合的交集</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sinterstore.html"><span>SINTERSTORE</span></a></span></td><td><span class="inline-wrap">求两个或多个集合的交集，并将结果保存到指定的集合(key)中</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/smembers.html"><span>SMEMBERS</span></a></span></td><td><span class="inline-wrap">查看集合中所有元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/smove.html"><span>SMOVE</span></a></span></td><td><span class="inline-wrap">将集合中的元素移动到指定的集合中</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/spop.html"><span>SPOP</span></a></span></td><td><span class="inline-wrap">弹出指定数量的元素</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/srandmember.html"><span>SRANDMEMBER</span></a></span></td><td><span class="inline-wrap">随机从集合中返回指定数量的元素，默认返回 1<span class="jill"></span>个</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/srem.html"><span>SREM</span></a></span></td><td><span class="inline-wrap">删除一个或者多个元素，若元素不存在则自动忽略</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sunion.html"><span>SUNION</span></a></span></td><td><span class="inline-wrap">求两个或者多个集合的并集</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/sunsionstore.html"><span>SUNIONSTORE</span></a></span></td><td><span class="inline-wrap">求两个或者多个集合的并集，并将结果保存到指定的集合(key)中</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">Zset 命令</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">zset 是 Redis 提供的最具特色的数据类型之一，首先它是一个 set，这保证了内部 value 值的唯一性，其次它给每个 value 添加了一个 score（分值）属性，通过对分值的排序实现了有序化。比如用 zset 结构来存储学生的成绩，value 值代表学生的 ID，score 则是的考试成绩。我们可以对成绩按分数进行排序从而得到学生的的名次。  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">下面列出了 zset 的常用命令，如下所示：</span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 150px"><span class="inline-wrap">命令</span></th><th style="width: 581px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zadd.html"><span>ZADD</span></a></span></td><td><span class="inline-wrap">用于将一个或多个成员添加到有序集合中，或者更新已存在成员的 score 值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zcard.html"><span>ZCARD</span></a></span></td><td><span class="inline-wrap">获取有序集合中成员的数量</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zcount.html"><span>ZCOUNT</span></a></span></td><td><span class="inline-wrap">用于统计有序集合中指定 score 值范围内的元素个数</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zincrby.html"><span>ZINCRBY</span></a></span></td><td><span class="inline-wrap">用于增加有序集合中成员的分值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zinterstore.html"><span>ZINTERSTORE</span></a></span></td><td><span class="inline-wrap">求两个或者多个有序集合的交集，并将所得结果存储在新的 key 中</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrange.html"><span>ZRANGE</span></a></span></td><td><span class="inline-wrap">返回有序集合中指定索引区间内的成员数量</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrangebylex.html"><span>ZRANGEBYLEX</span></a></span></td><td><span class="inline-wrap">返回有序集中指定字典区间内的成员数量</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrangebyscore.html"><span>ZRANGEBYSCORE</span></a></span></td><td><span class="inline-wrap">返回有序集合中指定分数区间内的成员</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrank.html"><span>ZRANK</span></a></span></td><td><span class="inline-wrap">返回有序集合中指定成员的排名</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrem.html"><span>ZREM</span></a></span></td><td><span class="inline-wrap">移除有序集合中的一个或多个成员</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zremrangebyrank.html"><span>ZREMRANGEBYRANK</span></a></span></td><td><span class="inline-wrap">移除有序集合中指定排名区间内的所有成员</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zremrangebyscore.html"><span>ZREMRANGEBYSCORE</span></a></span></td><td><span class="inline-wrap">移除有序集合中指定分数区间内的所有成员</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrevrange.html"><span>ZREVRANGE</span></a></span></td><td><span class="inline-wrap">返回有序集中指定区间内的成员，通过索引，分数从高到低</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zrevrank.html"><span>ZREVRANK</span></a></span></td><td><span class="inline-wrap">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zscore.html"><span>ZSCORE</span></a></span></td><td><span class="inline-wrap">返回有序集中，指定成员的分数值</span></td></tr><tr><td><span class="inline-wrap"><a href="http://c.biancheng.net/redis2/zunionstore.html"><span>ZUNIONSTORE</span></a></span></td><td><span class="inline-wrap">求两个或多个有序集合的并集，并将返回结果存储在新的 key 中</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+ 配置<span class="jill"></span>redis.conf</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>安装&gt; etc&gt; redis.conf</code></span><span class="inline-wrap"> 配置项说明如下：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>注意</b></span><span class="inline-wrap">，下面配置项说明并不全，了解更多请检阅 redis.conf。</span></div></div><div class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 38px"><span class="inline-wrap">序号</span></th><th style="width: 151px"><span class="inline-wrap">配置项</span></th><th style="width: 569px"><span class="inline-wrap">说明</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">1</span></td><td><span class="inline-wrap"><code>daemonize no</code></span></td><td><span class="inline-wrap">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</span></td></tr><tr><td><span class="inline-wrap">2</span></td><td><span class="inline-wrap"><code>pidfile /var/run/redis.pid</code></span></td><td><span class="inline-wrap">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</span></td></tr><tr><td><span class="inline-wrap">3</span></td><td><span class="inline-wrap"><code>port 6379</code></span></td><td><span class="inline-wrap">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</span></td></tr><tr><td><span class="inline-wrap">4</span></td><td><span class="inline-wrap"><code>bind 127.0.0.1</code></span></td><td><span class="inline-wrap">绑定的主机地址</span></td></tr><tr><td><span class="inline-wrap">5</span></td><td><span class="inline-wrap"><code>timeout 300</code></span></td><td><span class="inline-wrap">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</span></td></tr><tr><td><span class="inline-wrap">6</span></td><td><span class="inline-wrap"><code>loglevel notice</code></span></td><td><span class="inline-wrap">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</span></td></tr><tr><td><span class="inline-wrap">7</span></td><td><span class="inline-wrap"><code>logfile stdout</code></span></td><td><span class="inline-wrap">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</span></td></tr><tr><td><span class="inline-wrap">8</span></td><td><span class="inline-wrap"><code>databases 16</code></span></td><td><span class="inline-wrap">设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id</span></td></tr><tr><td><span class="inline-wrap">9</span></td><td><span class="inline-wrap"><code>save &lt;seconds&gt; &lt;changes&gt;
</code></span><span class="inline-wrap">Redis 默认配置文件中提供了三个条件：
</span><span class="inline-wrap"><code>save 900 1
save 300 10
save 60 10000</code></span></td><td><span class="inline-wrap">分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。
 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span></td></tr><tr><td><span class="inline-wrap">10</span></td><td><span class="inline-wrap"><code>rdbcompression yes</code></span></td><td><span class="inline-wrap">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</span></td></tr><tr><td><span class="inline-wrap">11</span></td><td><span class="inline-wrap"><code>dbfilename dump.rdb</code></span></td><td><span class="inline-wrap">指定本地数据库文件名，默认值为 dump.rdb</span></td></tr><tr><td><span class="inline-wrap">12</span></td><td><span class="inline-wrap"><code>dir ./</code></span></td><td><span class="inline-wrap">指定本地数据库存放目录</span></td></tr><tr><td><span class="inline-wrap">13</span></td><td><span class="inline-wrap"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></span></td><td><span class="inline-wrap">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</span></td></tr><tr><td><span class="inline-wrap">14</span></td><td><span class="inline-wrap"><code>masterauth &lt;master-password&gt;</code></span></td><td><span class="inline-wrap">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</span></td></tr><tr><td><span class="inline-wrap">15</span></td><td><span class="inline-wrap"><code>requirepass foobared</code></span></td><td><span class="inline-wrap">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH &lt;password&gt; 命令提供密码，默认关闭</span></td></tr><tr><td><span class="inline-wrap">16</span></td><td><span class="inline-wrap"><code>maxclients 128</code></span></td><td><span class="inline-wrap">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span></td></tr><tr><td><span class="inline-wrap">17</span></td><td><span class="inline-wrap"><code>maxmemory &lt;bytes&gt;</code></span></td><td><span class="inline-wrap">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</span></td></tr><tr><td><span class="inline-wrap">18</span></td><td><span class="inline-wrap"><code>appendonly no</code></span></td><td><span class="inline-wrap">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</span></td></tr><tr><td><span class="inline-wrap">19</span></td><td><span class="inline-wrap"><code>appendfilename appendonly.aof</code></span></td><td><span class="inline-wrap">指定更新日志文件名，默认为 appendonly.aof</span></td></tr><tr><td><span class="inline-wrap">20</span></td><td><span class="inline-wrap"><code>appendfsync everysec</code></span></td><td><span class="inline-wrap">指定更新日志条件，共有 3 个可选值：
no：表示等操作系统进行数据缓存同步到磁盘（快）
always：表示每次更新操作后手动调用 fsync () 将数据写到磁盘（慢，安全）
everysec：表示每秒同步一次（折中，默认值）
</span></td></tr><tr><td><span class="inline-wrap">21</span></td><td><span class="inline-wrap"><code>vm-enabled no</code></span></td><td><span class="inline-wrap">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将浏览量较少的页即冷数据 swap 到磁盘上，浏览多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</span></td></tr><tr><td><span class="inline-wrap">22</span></td><td><span class="inline-wrap"><code>vm-swap-file /tmp/redis.swap</code></span></td><td><span class="inline-wrap">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</span></td></tr><tr><td><span class="inline-wrap">23</span></td><td><span class="inline-wrap"><code>vm-max-memory 0</code></span></td><td><span class="inline-wrap">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的 (Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</span></td></tr><tr><td><span class="inline-wrap">24</span></td><td><span class="inline-wrap"><code>vm-page-size 32</code></span></td><td><span class="inline-wrap">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</span></td></tr><tr><td><span class="inline-wrap">25</span></td><td><span class="inline-wrap"><code>vm-pages 134217728</code></span></td><td><span class="inline-wrap">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</span></td></tr><tr><td><span class="inline-wrap">26</span></td><td><span class="inline-wrap"><code>vm-max-threads 4</code></span></td><td><span class="inline-wrap">设置连接 swap 文件的线程数，最好不要超过机器的核数，如果设置为 0, 那么所有对 swap 文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</span></td></tr><tr><td><span class="inline-wrap">27</span></td><td><span class="inline-wrap"><code>glueoutputbuf yes</code></span></td><td><span class="inline-wrap">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></td></tr><tr><td><span class="inline-wrap">28</span></td><td><span class="inline-wrap"><code>hash-max-zipmap-entries 64
hash-max-zipmap-value 512</code></span></td><td><span class="inline-wrap">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span></td></tr><tr><td><span class="inline-wrap">29</span></td><td><span class="inline-wrap"><code>activerehashing yes</code></span></td><td><span class="inline-wrap">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</span></td></tr><tr><td><span class="inline-wrap">30</span></td><td><span class="inline-wrap"><code>include /path/to/local.conf</code></span></td><td><span class="inline-wrap">指定包含其它的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span></td></tr></tbody></table></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+* 持久化</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><u>RDB</u></span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">什么是<span class="jill"></span>RDB？</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16524213809671652421380286.png" style="width: 926px"/></figure></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。</span></li></ul><blockquote class="wolai-block"><span class="inline-wrap">Fork</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap">Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">怎么配置？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">安装目录 &gt; etc &gt; redis.conf 的 快照部分（SNAPSHOTTING ） 作如下配置，其中触发 </span><span class="inline-wrap"><code>save &lt;秒&gt; &lt;改的次数&gt;</code></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>################################ SNAPSHOTTING  ################################
# 如果满足以下策略，就会将数据同步到磁盘
# <span class="token number">900</span> 秒内有 <span class="token number">1</span> 次修改、<span class="token number">300</span> 秒内有 <span class="token number">10</span> 次修改、<span class="token number">60</span> 秒内有 <span class="token number">10000</span> 次修改
# 任何一个条件满足，都会将文件写入到磁盘上，当然这数值我们是可以修改的
# 如果想立刻备份，那么直接在命令行输入 save 即可，会立刻备份，此时会处于阻塞状态，其他所有命令都会阻塞
# 也可以输入 bgsave 命令进行备份，和 save 不同的是，bgsave 是在后台异步进行快照。
# 并且还可以通过 lastsave 命令获取最后一次成功执行快照的时间
save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>

# 当快照操作出错时停止写数据到磁盘，这样后面写操作均会失败。
# 比如内存 <span class="token number">4</span>GB，但是当前主进程使用的 <span class="token number">3</span>GB
# 那么将数据写入磁盘、fork 一份主进程的时候就又需要额外的 <span class="token number">3</span>GB，显然内存不够了，因此保存到硬盘的数据也就失败了
# 为了不影响后续写操作，可以将该项值改为 no
stop<span class="token operator">-</span>writes<span class="token operator">-</span>on<span class="token operator">-</span>bgsave<span class="token operator">-</span>error yes

# 是否压缩，默认是 yes，采用 lzf 方式压缩。
# 如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为 no，缺点是需要更多的空间来存储文件
rdbcompression yes

# 对 rdb 数据进行校验<span class="token punctuation">,</span> 表示表示写入文件和读取文件时是否开启 RDB 文件检查
# 检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。
# 这个过程耗费 CPU 资源，会大概增加 <span class="token number">10</span><span class="token operator">%</span> 的性能损耗，默认为 yes
rdbchecksum yes

# rdb 文件名，所以默认是 rdb，并且也是默认开启 rdb 持久化
# 如果把上面所有的 save 给注释掉，那么就相当于关闭 rdb
dbfilename dump<span class="token punctuation">.</span>rdb

# 路径，这里的路径，如果你不单独指定，那么默认是 redis 的启动路径
# 也就是你是在哪个目录下启动的 redis<span class="token operator">-</span>server，那么 dir 就是哪里，但同时这也是 rdb 文件的所在路径
# 比如我是在 <span class="token operator">/</span>root 下面执行的 redis<span class="token operator">-</span>server，那么 dir 就是 <span class="token operator">/</span>root，同时 rdb 文件的路径也是 <span class="token operator">/</span>root<span class="token operator">/</span>dump<span class="token punctuation">.</span>rdb
dir <span class="token punctuation">.</span>/
</pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何手动触发？</span></summary><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">除了配置文件的&quot;save  多少秒  修改次数&quot;  </span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span></pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">命令 save 或者是 bgsave</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Save：save 时只管保存，其它不管，全部阻塞</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">BGSAVE：Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过 lastsave 命令获取最后一次成功执行快照的时间</span></li></ul></li></ol></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">保存在哪里？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">rdb 保存的是 dump.rdb 文件</span><span class="inline-wrap"><b>，</b></span><span class="inline-wrap"> 生成在</span><span class="inline-wrap"><code>安装 &gt; etc</code></span><span class="inline-wrap"> 下。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">要进行冷备份，将这个配置文件备份在别的机器，出现问题时进行恢复。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何恢复？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">将备份的<span class="jill"></span>dump.rdb<span class="jill"></span>文件放在</span><span class="inline-wrap"><code>安装目录 &gt; etc</code></span><span class="inline-wrap"> 下启动服务 </span><span class="inline-wrap"><code>redis-service /usr/local/redis/etc/redis.conf</code></span><span class="inline-wrap">  会自动恢复</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何关闭<span class="jill"></span>rdb?</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>命令</b></span><span class="inline-wrap">：config set save &quot;&quot;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>配置文件：</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">进入配置文件关闭触发策略即可：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Save 900 1      </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Save 300 10    </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Save 60 10000   </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注释掉，并打开<span class="jill"></span>save &quot;&quot; 的注释，使得  </span><span class="inline-wrap"><b>save &quot;&quot;</b></span><span class="inline-wrap">  生效，即可关闭<span class="jill"></span>rdb；)</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">rdb<span class="jill"></span>优势与劣势</span></summary><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">优势</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">适合大规模的数据恢复</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">对数据完整性和一致性要求不高</span></li></ul></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">劣势</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就 会丢失最后一次快照后的所有修改</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</span></li></ul></li></ul></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><u>AOF</u></span></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">什么是<span class="jill"></span>AOF？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于<span class="jill"></span> RDB 文件的写入并</span><span class="inline-wrap"><b>不是实时的</b></span><span class="inline-wrap">，通过 RDB 文件仅仅能将数据库状态恢复到</span><span class="inline-wrap"><b>上一次 RDB 持久化的状态</b></span><span class="inline-wrap">，在此之后所做的改动将会被丢失，因此，RDB 持久化比较适用于对数据丢失不敏感的场合。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">为了应对对数据丢失比较敏感的场合，Redis 提供了另外一种持久化的方式，也就是本文要提到的 </span><span class="inline-wrap"><b>AOF 持久化</b></span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">与 RDB 持久化通过保存数据库中的键值对来记录数据库状态的方式不同，AOF 持久化是通过</span><span class="inline-wrap"><b>保存 Redis 服务所执行的写命令</b></span><span class="inline-wrap">来记录数据库状态的。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何配置<span class="jill"></span>AOF？</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment">############################## APPEND ONLY MODE ###############################</span>
<span class="token comment"># aof 意思是 append only file，我们看到默认是 no，表示关闭，因此持久化默认使用 rdb</span>
appendonly no


<span class="token comment"># 正如 dump.rdb，aof 方式持久化也就一个文件名，默认叫appendonly.aof</span>
appendfilename <span class="token string">"appendonly.aof"</span>
<span class="token comment"># 另外 aof 和 rdb 持久化方式是可以同时指定的，后面会说</span>
<span class="token comment"># 另外我们知道当 redis 启动的时候，会加载文件，读进缓存。</span>
<span class="token comment"># 但如果既有 rdb 文件又有 aof 文件，那 redis 会读取哪个呢？实际上会读取 aof 文件</span>
<span class="token comment"># 如果 aof 被人乱搞了一通，那么会发现 redis 无法启动，启动了也连接不上。</span>
<span class="token comment"># 这个时候有两种办法，一种是删除相应的 aof 文件，但是这样数据就丢了</span>
<span class="token comment"># 还有一种方法，就是 redis-server 所在路径 (一般是/usr/local/bin) 中，有一个 redis-check-aof</span>
<span class="token comment"># 通过 redis-check-aof --fix appendonly.aof 可以进行修复，同理还有一个 redis-check-rdb，用来修复 rdb 文件。</span>


<span class="token comment"># appendfsync：同步策略，支持三个参数</span>
<span class="token comment"># 1.always：同步持久化，每次发生数据变更会被立即记录到磁盘，并完成同步，性能较差但是数据完整性较好</span>
<span class="token comment"># 2.everysec：默认设置，异步操作，每秒记录，并完成同步，如果1s内宕机，只丢失1s内的数据</span>
<span class="token comment"># 3.no：always 和 everysec 都会和磁盘保持同步，而 no 表示写入 aof 文件但并不等待磁盘同步，也就是写入缓冲区，Linux 中 30s 后自动同步到磁盘</span>
<span class="token comment"># appendfsync always</span>
appendfsync everysec
<span class="token comment"># appendfsync no</span>


<span class="token comment"># 子进程重写 aof 文件时是否不使用 appendfsync（开启子进程重写），用默认 no 即可，也就是使用，可以保证数据安全性</span>
<span class="token comment"># 注意这个参数前面有一个 no 了，设置为 yes，才表示不使用 appendfsync，因此这个参数有点绕</span>
<span class="token comment"># 如果设置为 yes，此时不会写入磁盘，只是写入缓冲区，因此不会造成阻塞。</span>
<span class="token comment"># 但如果 redis 挂掉，在 linux 系统默认设置下，会丢失 30s 的数据</span>
<span class="token comment"># 使用 no，表示使用 appendfsync，表示会由子进程重写，这时候和主进程之间会有资源上的竞争，因为都要操作磁盘，所以会有阻塞的情况，但是不会丢失数据。</span>
no-appendfsync-on-rewrite no


<span class="token comment"># aof 文件增长比例，指当前 aof 文件比上次重写的增长比例大小。</span>
<span class="token comment"># aof 重写即在 aof 文件在一定大小之后，重新将整个内存写到 aof 文件当中，以反映最新的状态(相当于bgsave)。</span>
<span class="token comment"># 这样就避免了，aof 文件过大而实际内存数据小的问题 (频繁修改数据问题).</span>
auto-aof-rewrite-percentage <span class="token number">100</span>


<span class="token comment"># aof 文件重写最小的文件大小，即最开始 aof 文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小)</span>
<span class="token comment"># 此变量仅初始化启动 redis 有效，如果是 redis 恢复时，则 lastSize 等于初始 aof 文件大小.</span>
auto-aof-rewrite-min-size 64mb


<span class="token comment"># 指 redis 在恢复时，会忽略最后一条可能存在问题的指令。</span>
<span class="token comment"># 默认值 yes。即在 aof 写入时，可能存在指令写错的问题(突然断电，写了一半)</span>
<span class="token comment"># 这种情况下，yes 会继续，而 no 会直接恢复失败，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。</span>
aof-load-truncated <span class="token function">yes</span>


<span class="token comment"># 4.0 开始允许使用 RDB-AOF 混合持久化的方式，结合了两者的优点，通过 aof-use-rdb-preamble 配置项可以打开混合开关</span>
aof-use-rdb-preamble <span class="token function">yes</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>其中比较重要的是 appendfsync 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</b></span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何修复<span class="jill"></span>aof<span class="jill"></span>文件？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用 </span><span class="inline-wrap"><code>redis → bin → redis-check-aof </code></span><span class="inline-wrap"> 进行修复</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">示例 ./redis-check-aof --fix  ../etc/appendonly.aof </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">就会删掉不符合的行</span></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">总结：RDB<span class="jill"></span>性能好，但一旦出现问题，可能就会丢去很长时间的数据，用于对数据丢失不敏感的场景。而<span class="jill"></span>AOF 通过配置，AOF<span class="jill"></span>最多不超过<span class="jill"></span>1<span class="jill"></span>秒的数据。但要求硬盘大，也会影响性能。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+ 事务</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">redis<span class="jill"></span>事务的介绍</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16524324064831652432406347.png" style="width: 698.6666666666666px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>「 Redis 事务中没有像 MySQL 关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像 MySQL 那样执行事务失败时可以进行回滚的操作。 」</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Redis 事务是一组命令的集合，将多个命令进行打包，然后这些命令会被顺序地添加到队列中，并按照添加的顺序依次执行。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>这个与 Redis 的特点：「 快速、高效 」有着紧密的联系，因为回滚操作、以及像事务隔离级别那样的加锁解锁，是非常消耗性能的。所以，Redis 中执行事务的流程只需要以下简单的三个步骤：</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1. MULTI：「 表示开启一个事务 」，执行此命令后，后面执行的所有对 Redis 数据类型的操作命令「都会被顺序地放入队列中」。当执行 EXEC 命令后，队列中的命令会被依次执行。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">
2. DISCARD：「 放弃执行队列中的命令 」，可以类比为 MySQL 的回滚操作，「 并且将当前的状态从事务状态改为非事务状态」。

3. EXEC：该命令表示要「 顺序执行队列中的命令 」，执行完之后并将结果显示在客户端，「 同时将当前状态从事务状态改为非事务状态 」。若是执行该命令之前，有 key 被执行 WATCH 命令并且又被其它客户端修改，那么就会放弃执行队列中的所有命令，并在客户端显示报错信息；如果没有被修改，那么会继续执行队列中的所有命令。</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何使用事务</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16524302794101652430279129.png" style="width: 329px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>正常执行</b></span><span class="inline-wrap">：在事务中执行没有问题的，每一步都是正常的，直接事务完成。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> k1 v1
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> k2 v2
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">exec</span>
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>放弃事务：</b></span><span class="inline-wrap">我们在执行 </span><span class="inline-wrap"><code>MULTI</code></span><span class="inline-wrap"> 后发现命令有问题，想放弃当前这个事务，就执行</span><span class="inline-wrap"><code>DISCARD</code></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> xv1 xv1
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> DISCARD
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> keys *
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>全体边坐：</b></span><span class="inline-wrap">开启事务后，加入队列的命令不对时，然后执行<span class="jill"></span>EXEC<span class="jill"></span>后，这整个事务的命令都失效。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang=".properties" class="marker"></div><pre><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> <span class="token constant">MULTI</span>
<span class="token constant">OK</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> <span class="token keyword">set</span> k1 v1
<span class="token constant">QUEUED</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> <span class="token keyword">set</span> k2 v2
<span class="token constant">QUEUED</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> <span class="token function">setfsffs</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token constant">ERR</span> unknown command <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">setfsffs</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token keyword">with</span> args beginning <span class="token keyword">with</span><span class="token operator">:</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> <span class="token function">exec</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token constant">EXECABORT</span> <span class="token maybe-class-name">Transaction</span> discarded because <span class="token keyword">of</span> previous errors<span class="token punctuation">.</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>冤头债主：</b></span><span class="inline-wrap">开启事务后，命令正常加入队列 （但执行时会导致错误时），然后执行<span class="jill"></span>EXEC<span class="jill"></span>后，有问题的命令失效，其它正常执行。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> k1 v1
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> f f f
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">exec</span>
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR syntax error
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">监控</span></summary><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">介绍</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Redis 的监控会使用到锁机制，而锁分为悲观锁和乐观锁。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>类似于 MySQL 里面的 &quot;表锁&quot; 和 &quot;行锁&quot;。&quot;表锁&quot; 就是为了保证数据的一致性，将整张表锁上，这样就只能一个人修改，好比进卫生间，进去之后就把大门锁上了，但这样的结果也可想而知，虽然数据的一致性、安全性好，但是并发性会极差，因为其他人进不去了。比如一张有 20 万条记录的表，但是你只修改第 520 行，而另一个哥们修改第 250 行，本来两者不冲突，但是你把整个表都锁了，那就意味这后面的老铁只能排队了，这样显然效率不高。于是就出现了 &quot;行锁&quot;，&quot;行锁&quot; 在 MySQL 中，就类似于表中有一个版本号的字段，假设有一条记录的版本号为 1，A 和 B 同时修改这条记录，那么一旦提交，就会改变那个版本号，假设变为 2。如果 A 先提交了，那么数据库中对应记录的版本号已经变了，但是 B 对应的版本号还是之前的，那么提交之后会立即报错，这样就知道这条记录被人修改了，需要重新获取对应版本号的记录。</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">悲观锁与乐观锁</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>悲观锁：</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">pessimistic lock，顾名思义，就是很悲观，每次拿数据的时候都会认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿到这个数据就会 block 住，直到拿到锁。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>乐观锁：</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">optimistic lock，顾名思义，就是很乐观，每次拿数据的时候都会认为别人不会修改，所以每次拿数据的时候都不会上锁。但是在更新数据的时候会判断一下在此期间别人有没有去更新这条数据，可以使用版本号等机制。乐观锁使用于多读的应用类型，这样可以提高吞吐量。乐观锁策略就是：提交版本必须大于记录的当前版本才能更新。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">而 watch 命令则是用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个监控项被修改了，那么整个事务就会终止执行。</span></div></div></details><details class="wolai-block"><summary><div class="marker placeholder"></div><span class="inline-wrap"></span><br/></summary></details><blockquote class="wolai-block"><span class="inline-wrap">redis<span class="jill"></span>会监控监控项是否被修改，如果修改了，会关闭事务，使事务命令无效。</span></blockquote><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>WATCH &lt;表&gt;  #开启监控</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>UNWATCH  #取消监控，在<span class="jill"></span>MULTI<span class="jill"></span>命令执行前</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">监控演示：下面就来演示一下，首先 watch 是需要搭配 multi 事务来使用的。一般是先 watch key，然后开启事务对 key 操作。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"user"</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">命令窗口<span class="jill"></span>1：</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> WATCH user   <span class="token comment">#开启监控</span>
OK
<span class="token comment"># UNWATCH  #取消监控</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> MULTI       <span class="token comment">#开启事务，开启事务后取消监控无效</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">set</span> user <span class="token number">50</span>  <span class="token comment">#在这里另一个窗口修改了user的值</span>
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">exec</span>         <span class="token comment">#会执行无效</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>                       
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">- 消息订阅与发布</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap">订阅：</span><span class="inline-wrap">SUBSCRIBE </span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SUBSCRIBE xvideos
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"xvideos"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"xvideos"</span>
</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">发布：PUBLISH</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> PUBLISH xvideos <span class="token number">69</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">此时订阅窗口：加一行 </span><span class="inline-wrap"><code>3) &quot;69&quot;</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+* 主从复制</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>复制原理</b></span></div></div><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">slave 启动成功连接到 master 后会发送一个 sync 命令</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master 将传送整个数据文件到 slave, 以完成一次完全同步</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave, 完成同步</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">但是只要是重新连接 master，一次完全同步（全量复制) 将被自动执行</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>复制延时</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">由于所有的写操作都是先在 Master 上操作，然后同步更新到 slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">一主二仆</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16524487311761652448731077.png" style="width: 374px"/></figure></div><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">如何配置？</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">将</span><span class="inline-wrap"><code>安装目录 &gt; etc</code></span><span class="inline-wrap"> 的</span><span class="inline-wrap"><code>redis.conf</code></span><span class="inline-wrap"> 文件克隆三份，第三有所区别，要配置的项示例如下：打开以下文件搜索<span class="jill"></span>6380<span class="jill"></span>即可知道配置点，就是文件生成的名要不同，启动的端口不同，等等。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://github.com/18476305640/fileBox/blob/master/杂项/redis6380.conf"><span>https://github.com/18476305640/fileBox/blob/master/杂项/redis6380.conf</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">然后分别启动：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-server /usr/local/redis/etc/redis6379.conf</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-server /usr/local/redis/etc/redis6380.conf</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-server /usr/local/redis/etc/redis6381.conf</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">启动后，分别在不同窗口执行以下命令进入<span class="jill"></span>redis<span class="jill"></span>操作命令：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-cli -p 6379  #master</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-cli -p 6380  #slave</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-cli -p 6381  #slave</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">在这些窗口执行 </span><span class="inline-wrap"><code>INFO replication</code></span><span class="inline-wrap"> 查看当前信息，发现都是<span class="jill"></span>master，我们要让<span class="jill"></span>6380、6381<span class="jill"></span>作为<span class="jill"></span>slave，那么在这两个窗口执行：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">slaveof 主库<span class="jill"></span>IP 主库端口</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">即：slaveof 127.0.0.1 6379</span></div></div></details><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">  </span><span class="inline-wrap"><b>主从问题演示</b></span></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">切入点问题？slave1、slave2 是从头开始复制还是从切入点开始复制？比如从 k4 进来，那之前的 123 是否也可以复制？</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：从头开始复制；123 也可以复制</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">从机是否可以写？set 可否？</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：从机不可写，不可 set，主机可写</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">主机 shutdown 后情况如何？从机是上位还是原地待命</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：从机还是原地待命（咸鱼翻身，还是咸鱼）</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">主机又回来了后，主机新增记录，从机还能否顺利复制？</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：能</span></div></div></li><li><div class="marker"></div><span class="inline-wrap">其中一台从机 down 后情况如何？依照原有它能跟上大部队吗？</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：不能跟上，每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件（具体位置：redis.conf 搜寻</span><span class="inline-wrap"><code>#### REPLICATION ####</code></span><span class="inline-wrap">）</span></div></div></li></ol></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">薪火相传</span></summary><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16524490471251652449046262.png" style="width: 519px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">6379<span class="jill"></span>是<span class="jill"></span>6380<span class="jill"></span>的<span class="jill"></span>master , 6380<span class="jill"></span>是<span class="jill"></span>6381<span class="jill"></span>的<span class="jill"></span>master。 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">slaveof 主库<span class="jill"></span>IP 主库端口</span></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">反客为主</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>SLAVEOF no one</code></span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">退出<span class="jill"></span>slave，使当前数据库停止与其他数据库的同步，转成主数据库</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">哨兵模式</span></summary><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">调整结构，6379 带着 6380、6381</span></li><li><div class="marker"></div><span class="inline-wrap">配置：加一个配置文件</span><span class="inline-wrap"><code>安装目录 &gt; etc &gt;  sentinel.conf</code></span><span class="inline-wrap"> (名字绝不能错)，内容是:</span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre><span class="token comment">#一个哨兵可以监控多个master</span>
sentinel monitor 被监控数据库名字<span class="token punctuation">(</span>自己起名字<span class="token punctuation">)</span> <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span></pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">启动哨兵 </span><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Bash" class="marker"></div><pre>redis-sentinel /usr/local/redis/etc/sentinel.conf </pre></div></code-block></li><li><div class="marker"></div><span class="inline-wrap">测试</span><div class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>master<span class="jill"></span>上即<span class="jill"></span>6379<span class="jill"></span>上执行</span><span class="inline-wrap"><code>SHUTDOWN</code></span><span class="inline-wrap"> 那么观察<span class="jill"></span>sentinel<span class="jill"></span>窗口，会进行投票，先一个新的<span class="jill"></span>slave<span class="jill"></span>作为<span class="jill"></span>master。 再次启动<span class="jill"></span>6379<span class="jill"></span>发现，6379<span class="jill"></span>不再是<span class="jill"></span>master<span class="jill"></span>而是作为新体系下的<span class="jill"></span>slave。</span></div></div></li></ol></details><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis-sentinel /sentinel.conf </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">+ jedis</span></h3><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">准备</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">1) 配置</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">redis.conf 配置为任何主机可访问（远程访问）。</span><span class="inline-wrap"><code>0.0.0.0</code></span><span class="inline-wrap">表示 任何主机可访问</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16525129593471652512959212.png" style="width: 686px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2）依赖</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="XML" class="marker"></div><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">测试连通</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">test1.java</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>zjazn<span class="token punctuation">.</span>redis</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"124.222.229.234"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//输出PONG，redis连通成功</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">基本操作</span></summary><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Response</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Transaction</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 监控key，如果该动了事务就被放弃</span>
    <span class="token comment">/*
     * 3 jedis.watch("serialNum"); jedis.set("serialNum","s#####################");
     * jedis.unwatch();
     */</span>

    <span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 被当作一个命令进行执行</span>
    <span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> response <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"serialNum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    transaction<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"serialNum"</span><span class="token punctuation">,</span> <span class="token string">"s002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"serialNum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    transaction<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"list3"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    transaction<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"list3"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    transaction<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"list3"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2 transaction.discard();</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"serialNum***********"</span> <span class="token operator">+</span> response<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">事务</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://gitee.com/jallenkwong/LearnRedis/blob/master/src/main/java/com/lun/shang/TestTX.java"><span>TestTX.java</span></a></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Transaction</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestTX</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">transMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> balance<span class="token punctuation">;</span><span class="token comment">// 可用余额</span>
    <span class="token keyword">int</span> debt<span class="token punctuation">;</span><span class="token comment">// 欠额</span>
    <span class="token keyword">int</span> amtToSubtract <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 实刷额度</span>

    jedis<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// jedis.set("balance","5");//此句不该出现，讲课方便。模拟其他程序已经修改了该条目</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">7000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    balance <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balance <span class="token operator">&lt;</span> amtToSubtract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      jedis<span class="token punctuation">.</span><span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"modify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"***********transaction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      transaction<span class="token punctuation">.</span><span class="token function">decrBy</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">,</span> amtToSubtract<span class="token punctuation">)</span><span class="token punctuation">;</span>
      transaction<span class="token punctuation">.</span><span class="token function">incrBy</span><span class="token punctuation">(</span><span class="token string">"debt"</span><span class="token punctuation">,</span> amtToSubtract<span class="token punctuation">)</span><span class="token punctuation">;</span>
      transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      balance <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"balance"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      debt <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"debt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*******"</span> <span class="token operator">+</span> balance<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*******"</span> <span class="token operator">+</span> debt<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token doc-comment comment">/**
   * 通俗点讲，watch命令就是标记一个键，如果标记了一个键， 在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中 重新再尝试一次。
   * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减； 足够的话，就启动事务进行更新操作，
   * 如果在此期间键balance被其它人修改， 那在提交事务（执行exec）时就会报错， 程序中通常可以捕获这类错误再重新执行一次，直到成功。
   * 
   * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">InterruptedException</span></span>
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">TestTX</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestTX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> retValue <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">transMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main retValue-------: "</span> <span class="token operator">+</span> retValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">主从复制</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://gitee.com/jallenkwong/LearnRedis/blob/master/src/main/java/com/lun/shang/TestMS.java"><span>TestMS.java</span></a></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestMS</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Jedis</span> jedis_M <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Jedis</span> jedis_S <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6380</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    jedis_S<span class="token punctuation">.</span><span class="token function">slaveof</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    jedis_M<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span> <span class="token string">"1122V2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> result <span class="token operator">=</span> jedis_S<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可能有延迟，需再次启动才能使用</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></details><details class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">JedisPoolUtil</span></summary><div class="wolai-block wolai-text"><div><span class="inline-wrap">JedisPoolUtil</span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">获取<span class="jill"></span>Jedis<span class="jill"></span>实例需要从<span class="jill"></span>JedisPool<span class="jill"></span>中获取</span></li><li><div class="marker"></div><span class="inline-wrap">用完<span class="jill"></span>Jedis<span class="jill"></span>实例需要返还给<span class="jill"></span>JedisPool</span></li><li><div class="marker"></div><span class="inline-wrap">如果<span class="jill"></span>Jedis<span class="jill"></span>在使用过程中出错，则也需要还给<span class="jill"></span>JedisPool</span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://gitee.com/jallenkwong/LearnRedis/blob/master/src/main/java/com/lun/shang/JedisPoolUtil.java"><span>JedisPoolUtil.java</span></a></span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPool</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPoolConfig</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisPoolUtil</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">JedisPool</span> jedisPool <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token class-name">JedisPoolUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> <span class="token function">getJedisPoolInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> jedisPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">JedisPoolUtil</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> jedisPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">JedisPoolConfig</span> poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          poolConfig<span class="token punctuation">.</span><span class="token function">setMaxActive</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          poolConfig<span class="token punctuation">.</span><span class="token function">setMaxWait</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          poolConfig<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> jedisPool<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">JedisPool</span> jedisPool<span class="token punctuation">,</span> <span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      jedisPool<span class="token punctuation">.</span><span class="token function">returnResourceObject</span><span class="token punctuation">(</span>jedis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span></pre></div></code-block></details></article><footer></footer></body></html>