<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>我的面试题 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;https://cdn.wostatic.cn/cover/nature/c7E5gB2EB6nxkh1EDUyusP.jpg&quot;)"></div><div class="title"><div class="banner"><div data-symbol="📽️" class="icon"></div></div><div data-title="我的面试题" class="main-title"></div></div></header><article><div class="wolai-block wolai-text"><div><span class="inline-wrap">别人的面试经：</span></div></div><div class="wolai-bookmark wolai-block"><a href="https://juejin.cn/post/6844904125709156359">Spring Boot面试题（总结最全面的面试题！！！） - 掘金</a><div class="info-box"><div class="text-pane"><div data-title="Spring Boot面试题（总结最全面的面试题！！！） - 掘金"></div><div data-desc="Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。 SpringBoot是快速开发的Spring框架，SpringCloud是完整的…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png&quot;)"></div><div data-hostname="juejin.cn"></div></div></div><div class="preview-pane"></div></div></div><h3 class="wolai-block"><span class="inline-wrap">1.0 spring</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">2.0 springmvc</span></h3><h4 class="wolai-block"><span class="inline-wrap">2.1 什么是<span class="jill"></span>MVC<span class="jill"></span>模式？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">答：是模型-视图-控制器的简称，是一种软件设计的典范。它是用业务逻辑、数据与界面显示分离方法来组织代码。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">M<span class="jill"></span>是模型、V<span class="jill"></span>是视图、C<span class="jill"></span>是控制器。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">2.2 SpringMVC<span class="jill"></span>的执行流程？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">1.用户发送请求至前端控制器<span class="jill"></span>DispatcherServlet</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2.DispatcherServlet<span class="jill"></span>收到请求调用处理器映射器<span class="jill"></span>HandlerMapping。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">3.处理器映射器根据请求<span class="jill"></span>url<span class="jill"></span>找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<span class="jill"></span>DispatcherServlet（此时处理器映射器返回的处理器对象包含：包名<span class="jill"></span>+<span class="jill"></span>类名<span class="jill"></span>+<span class="jill"></span>方法名）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">4.DispatcherServlet<span class="jill"></span>通过<span class="jill"></span>HandlerAdapter<span class="jill"></span>处理器适配器调用处理器</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">5.处理器适配器<span class="jill"></span>HandlerAdapter<span class="jill"></span>将会根据适配的结果去执行<span class="jill"></span>Handler。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">6.Handler<span class="jill"></span>执行完成返回<span class="jill"></span>ModelAndView。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">7.HandlerAdapter<span class="jill"></span>将<span class="jill"></span>Handler<span class="jill"></span>执行结果<span class="jill"></span>ModelAndView<span class="jill"></span>返回到前端控制器<span class="jill"></span>DispatcherServlet</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8.前端控制器<span class="jill"></span>DispatcherServlet<span class="jill"></span>将<span class="jill"></span>ModelAndView<span class="jill"></span>传给<span class="jill"></span>ViewReslover<span class="jill"></span>视图解析器。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">9.视图解析器<span class="jill"></span>ViewReslover<span class="jill"></span>解析后返回具体<span class="jill"></span>View</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">10.前端控制器<span class="jill"></span>DispatcherServlet<span class="jill"></span>对<span class="jill"></span>View<span class="jill"></span>进行渲染视图。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">11.前端控制器<span class="jill"></span>DispatcherServlet<span class="jill"></span>向用户响应结果。 </span></div></div><h4 class="wolai-block"><span class="inline-wrap">2.3 SpringMVC<span class="jill"></span>有哪些优点？</span></h4><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">SpringMVC<span class="jill"></span>本身是与<span class="jill"></span>Spring<span class="jill"></span>框架结合而成的，它同时拥有<span class="jill"></span>Spring<span class="jill"></span>的优点(例如依赖注入<span class="jill"></span>DI<span class="jill"></span>和切面编程<span class="jill"></span>AOP<span class="jill"></span>等)。</span></li><li><div class="marker"></div><span class="inline-wrap">SpringMVc<span class="jill"></span>提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。</span></li><li><div class="marker"></div><span class="inline-wrap">支持灵活的<span class="jill"></span>URL<span class="jill"></span>到页面控制器的映射。</span></li><li><div class="marker"></div><span class="inline-wrap">可以方便地与其他视图技术(JSP、FreeMarker<span class="jill"></span>等)进行整合。由于<span class="jill"></span>SpringMVC<span class="jill"></span>的模型数据往往是放置在<span class="jill"></span>Map<span class="jill"></span>数据结构中的，因此其可以很方便地被其他框架引用。</span></li><li><div class="marker"></div><span class="inline-wrap">拥有十分简洁的异常处理机制。</span></li><li><div class="marker"></div><span class="inline-wrap">可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。</span></li><li><div class="marker"></div><span class="inline-wrap">支持<span class="jill"></span>RestFul<span class="jill"></span>风格。</span></li></ol><h4 class="wolai-block"><span class="inline-wrap">2.4 SpingMVC<span class="jill"></span>主要组件</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">前端控制器：接收前端请求，然后给用户反馈</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">处理器映射器：收集处理器</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">处理器适配器：执行处理器</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">视图解析器：根据<span class="jill"></span>ModelAndView<span class="jill"></span>返回具体的视图</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">视图：是一个接口</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">处理器：是请求的处理逻辑，返回相应的数据和视图信息，并封装到<span class="jill"></span>ModelAndView<span class="jill"></span>中</span></div></div><h4 class="wolai-block"><span class="inline-wrap">2.5 SpringMVC<span class="jill"></span>和<span class="jill"></span>Struts2<span class="jill"></span>的区别有哪些?</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">入口不同、url<span class="jill"></span>的映射关系不同、</span></div></div><h4 class="wolai-block"><span class="inline-wrap">2.6 SpringMVC<span class="jill"></span>怎么样设定重定向和请求转发？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">都是通过返回一个<span class="jill"></span>String</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">重定向： &quot;redirect:页面&quot;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">转发：&quot;forward:页面&quot;</span></div></div><h4 class="wolai-block"><span class="inline-wrap">2.7<span class="jill"></span>怎么样把<span class="jill"></span>ModelMap<span class="jill"></span>里面的数据放入<span class="jill"></span>session<span class="jill"></span>里面？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>@SessionAttributes 注解</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.8 doDispatcher<span class="jill"></span>的执行流程</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">（1）调用<span class="jill"></span>mappedHandler = this.getHandler(processedRequest);  获取能够处理当前请求的执行链 HandlerExecutionChain （handler+<span class="jill"></span>拦截器）。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如何获取<span class="jill"></span>handler<span class="jill"></span>的？会遍历<span class="jill"></span>handlerMappings<span class="jill"></span>数组，对应的是不同的<span class="jill"></span>Mapper<span class="jill"></span>对象。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518867643421651886763638.png" style="width: 720.6666666666666px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（2）HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); 从执行链中获取<span class="jill"></span>handler<span class="jill"></span>调用<span class="jill"></span>getHandlerAdapter<span class="jill"></span>方法获取 HandlerAdapter 。</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">如何获取的<span class="jill"></span>handlerAdapter？会遍历<span class="jill"></span>handlerAdapters<span class="jill"></span>数组，对应的是不同的<span class="jill"></span>adapter<span class="jill"></span>对象。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518930253451651893025237.png" style="width: 715.3333333333334px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（3）mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 调用<span class="jill"></span>HandlerAdapter 的<span class="jill"></span>handle<span class="jill"></span>方法去执行那个<span class="jill"></span>handler<span class="jill"></span>得到<span class="jill"></span>ModelAndView。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">（4）this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 调用<span class="jill"></span>processDispatchResult<span class="jill"></span>方法结合<span class="jill"></span>mv<span class="jill"></span>完成视图渲染与跳转。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">2.9<span class="jill"></span>九大组件 </span></h4><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>    <span class="token comment">//多部件解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">MultipartResolver</span> multipartResolver<span class="token punctuation">;</span>
    <span class="token comment">//国际化解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">LocaleResolver</span> localeResolver<span class="token punctuation">;</span>
    <span class="token comment">//主题解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">ThemeResolver</span> themeResolver<span class="token punctuation">;</span>
    <span class="token comment">//处理器映射器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerMapping</span><span class="token punctuation">></span></span> handlerMappings<span class="token punctuation">;</span>
    <span class="token comment">//处理器适配器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">></span></span> handlerAdapters<span class="token punctuation">;</span>
    <span class="token comment">//异常解析器组件</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerExceptionResolver</span><span class="token punctuation">></span></span> handlerExceptionResolvers<span class="token punctuation">;</span>
    <span class="token comment">//默认视图名转换器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">RequestToViewNameTranslator</span> viewNameTranslator<span class="token punctuation">;</span>
    <span class="token comment">//flash属性管理组件</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">FlashMapManager</span> flashMapManager<span class="token punctuation">;</span>
    <span class="token comment">//视图解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ViewResolver</span><span class="token punctuation">></span></span> viewResolvers<span class="token punctuation">;</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.0<span class="jill"></span>组件的初始化</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">tomcat<span class="jill"></span>启动后，会有事件触发<span class="jill"></span>DisplayServlet<span class="jill"></span>调用<span class="jill"></span>onRefresh 方法，然后进行调用方法进行初始化。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.1 SpringMVC<span class="jill"></span>主要组件（五大组件）；*
</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">DispatcherServlet：前端控制器，用于请求到达前端控制器，由它调用其他组件处理用户的请求。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HandlerMapping：处理器映射器，负责根据用户请求找到<span class="jill"></span>Handler(处理器)，springmvc<span class="jill"></span>提供了不同的映射器实现方式。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">Handler：后端控制器（处理器），对具体的用户请求进行处理。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HandlerAdapter：处理器适配器，通过<span class="jill"></span>HandlerAdapter<span class="jill"></span>对处理器进行执行。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">View Resolver：视图解析器，负责将处理结果生成<span class="jill"></span>view<span class="jill"></span>视图。 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.2 SpringMVC<span class="jill"></span>有哪些注解</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@RequestBody：注解实现接收<span class="jill"></span>http<span class="jill"></span>请求的<span class="jill"></span>json<span class="jill"></span>数据，将<span class="jill"></span>json<span class="jill"></span>转换为<span class="jill"></span>java<span class="jill"></span>对象。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@ResponseBody：注解实现将<span class="jill"></span>conreoller<span class="jill"></span>方法返回对象转化为<span class="jill"></span>json<span class="jill"></span>对象响应给客户。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@Resource<span class="jill"></span>和<span class="jill"></span>@Autowired：@Resource<span class="jill"></span>和<span class="jill"></span>@Autowired<span class="jill"></span>都是做<span class="jill"></span>bean<span class="jill"></span>的注入时使用，其实<span class="jill"></span>            @Resource<span class="jill"></span>并不是<span class="jill"></span>Spring<span class="jill"></span>的注解，它的包是<span class="jill"></span>javax.annotation.Resource，需要导入，但是<span class="jill"></span>Spring<span class="jill"></span>支持该注解的注入。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">@PathVariable<span class="jill"></span>用于将请求<span class="jill"></span>URL<span class="jill"></span>中的模板变量映射到功能处理方法的参数上，即取出<span class="jill"></span>uri<span class="jill"></span>模板中的变量作为参数</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.3 SpringMVC<span class="jill"></span>怎么样设定重定向和转发的？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">1、转发：在返回值前面加&quot;forward:&quot;，譬如&quot;forward:user.do?name=method4&quot;</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、重定向：在返回值前面加&quot;redirect:&quot;，譬如&quot;redirect:</span><span class="inline-wrap"><a href="http://www.baidu.com"><span>http://www.baidu.com</span></a></span><span class="inline-wrap">&quot;可能会问转发与重定向的区别。 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.4 Spring<span class="jill"></span>事务传播机制是什么；
</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Spring<span class="jill"></span>事务定义了<span class="jill"></span>7<span class="jill"></span>种传播机制：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1、PROPAGATION_REQUIRED:默认的<span class="jill"></span>Spring<span class="jill"></span>事物传播级别，若当前存在事务，则加入该事 务，若不存在事务，则新建一个事务。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2、PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">3、PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于<span class="jill"></span>REQUIRE_NEW。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">4、PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">5、PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂起。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">6、PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">7、PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">3.0 Springboot<span class="jill"></span>面试题</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">什么是 Spring Boot？</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">为什么要用<span class="jill"></span>SpringBoot</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">快速开发，快速整合，配置简化、内嵌服务容器</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">SpringBoot<span class="jill"></span>与<span class="jill"></span>SpringCloud 区别</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">SpringBoot<span class="jill"></span>是快速开发的<span class="jill"></span>Spring<span class="jill"></span>框架，SpringCloud<span class="jill"></span>是完整的微服务框架，SpringCloud<span class="jill"></span>依赖于<span class="jill"></span>SpringBoot。</span></li></ul><h4 class="wolai-block"><span class="inline-wrap">Spring Boot 有哪些优点？</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Spring Boot 主要有如下优点：</span><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</span></li><li><div class="marker"></div><span class="inline-wrap">开箱即用，远离繁琐的配置。</span></li><li><div class="marker"></div><span class="inline-wrap">提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</span></li><li><div class="marker"></div><span class="inline-wrap">SpringBoot<span class="jill"></span>总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</span></li></ol></li></ul><h4 class="wolai-block"><span class="inline-wrap">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">启动类上面的注解是<span class="jill"></span>@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</span><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@SpringBootConfiguration：组合了 @Configuration 注解，标注一个类为配置类，该类下的方法如果有<span class="jill"></span>@Bean, 那么会以方法名作为<span class="jill"></span>Bean<span class="jill"></span>的名字，返回值作为<span class="jill"></span>Bean<span class="jill"></span>的类型注入到<span class="jill"></span>Spring<span class="jill"></span>容器中。</span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：</span><span class="inline-wrap"><code>java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">@ComponentScan：Spring<span class="jill"></span>组件扫描。会扫描该类包下的所有配置类</span></li></ul></li></ul><h4 class="wolai-block"><span class="inline-wrap">SpringBoot Starter<span class="jill"></span>的工作原理</span></h4><ul class="wolai-block"><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><code>我个人理解<span class="jill"></span>SpringBoot<span class="jill"></span>就是由各种<span class="jill"></span>Starter<span class="jill"></span>组合起来的，我们自己也可以开发<span class="jill"></span>Starter</code></span></li><li><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在<span class="jill"></span>sprinBoot<span class="jill"></span>启动时由<span class="jill"></span>@SpringBootApplication<span class="jill"></span>注解会自动去<span class="jill"></span>maven<span class="jill"></span>中读取每个<span class="jill"></span>starter<span class="jill"></span>中的<span class="jill"></span>spring.factories<span class="jill"></span>文件,该文件里配置了所有需要被创建<span class="jill"></span>spring<span class="jill"></span>容器中的<span class="jill"></span>bean，并且进行自动配置把<span class="jill"></span>bean<span class="jill"></span>注入<span class="jill"></span>SpringContext<span class="jill"></span>中 //（SpringContext<span class="jill"></span>是<span class="jill"></span>Spring<span class="jill"></span>的配置文件）</span></li></ul><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">3.0 java<span class="jill"></span>面试题</span></h3><h4 class="wolai-block"><span class="inline-wrap">3.1 说一下，封装、继承、多态</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">封装：把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">继承：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">多态：多态性是对象多种表现形式的体现。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">抽象：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap"><b>3.2 String、StringBuffer、StringBuilder<span class="jill"></span>三者之间的区别</b></span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>String</b></span><span class="inline-wrap"> </span><span class="inline-wrap"><b>字符串常量</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>StringBuffer 字符串变量（线程安全）</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>StringBuilder 字符串变量（非线程安全）</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.3 String<span class="jill"></span>常用的方法</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">返回指定字符的索引：indexOf()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">返回指定索引处的字符：charAt()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符串替换：replace()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">去除字符串两端空白：trim()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">分割字符串，返回一个分割后的字符串数组：split()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">返回字符串的 byte 类型数组：getBytes()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">返回字符串长度：length()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">将字符串转成小写字母：toLowerCase()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">将字符串转成大写字符：toUpperCase()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">截取字符串：substring()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">字符串比较：equals()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.4 反射</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.5 JDB1.8<span class="jill"></span>的新特性</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">1 Lambda 表达式</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2 方法引用 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">3 函数式接口</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">4 接口允许定义默认方法和静态方法</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">5 Stream API  </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">6 日期/时间类改进 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">7 Optional 类</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">8 Java8 Base64 实现 </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.6 异常</span></h4><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519929145191651992914201.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.7 JDK<span class="jill"></span>源码</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">如果 HashMap</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.8 Java<span class="jill"></span>集合</span></h4><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519934905201651993485895.png" style="width: 512px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">(1)Connection</span><span class="inline-wrap"><b>接口</b></span><span class="inline-wrap">:</span><span class="inline-wrap"><b>List</b></span><span class="inline-wrap"> 有序,可重复</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>ArrayList</b></span><span class="inline-wrap">  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程不安全，效率高 </span><span class="inline-wrap"><b>Vector</b></span><span class="inline-wrap">  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程安全，效率低, 已给舍弃了 </span><span class="inline-wrap"><b>LinkedList</b></span><span class="inline-wrap">  优点: 底层数据结构是链表，查询慢，增删快。  缺点: 线程不安全，效率高</span><span class="inline-wrap"><b>Set</b></span><span class="inline-wrap"> 无序,唯一</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>HashSet</b></span><span class="inline-wrap">  底层数据结构是哈希表。(无序,唯一) 如何来保证元素唯一性? 依赖两个方法：hashCode()和<span class="jill"></span>equals()</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>LinkedHashSet</b></span><span class="inline-wrap">  底层数据结构是链表和哈希表。(FIFO<span class="jill"></span>插入有序,唯一)  </span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1.由链表保证元素有序 2.由哈希表保证元素唯一</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>TreeSet</b></span><span class="inline-wrap">  底层数据结构是红黑树。(唯一，有序)  </span></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">如何保证元素排序的呢? 自然排序  比较器排序 2.如何保证元素唯一性的呢?  </span></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap">根据比较的返回值是否是<span class="jill"></span>0<span class="jill"></span>来决定</span></div></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>(2)Map</b></span><span class="inline-wrap">接口有四个实现类： </span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>HashMap</b></span><span class="inline-wrap">   基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键， 线程不安全。  </span><span class="inline-wrap"><b>HashTable</b></span><span class="inline-wrap">   线程安全，低效，不支持 null 值和 null 键； </span><span class="inline-wrap"><b>LinkedHashMap</b></span><span class="inline-wrap">   线程不安全，是 HashMap 的一个子类，保存了记录的插入顺序； </span><span class="inline-wrap"><b>TreeMap</b></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">能够把它保存的记录根据键排序，默认是键值的升序排序，线程不安全。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">3.9 HashMap</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">底层：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>前是数组<span class="jill"></span>+<span class="jill"></span>链表</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">JDK1.8<span class="jill"></span>后是数组<span class="jill"></span>+<span class="jill"></span>链表 或 数组<span class="jill"></span>+<span class="jill"></span>红黑树（当链表长度 ≥ 8 时，≤ 6 时退化为链表）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">首次<span class="jill"></span>put<span class="jill"></span>时才会创建数组，长度为<span class="jill"></span>16，超过负载因子<span class="jill"></span>75%<span class="jill"></span>的容量时，乘于加载因子，会调用<span class="jill"></span>rehash<span class="jill"></span>方法使变为原来的两倍。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519937367691651993736687.png" style="width: 100%"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.10 有符号与无符号</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">看它的二进制的最高位，如果是<span class="jill"></span>1<span class="jill"></span>为负数，0<span class="jill"></span>为正数。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.11 原码、反码、补码</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">原码：就当前的</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">反码：符号位不变，其它按位取反。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">补码：反码<span class="jill"></span>+1</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">特别地：0<span class="jill"></span>的反码、补码都是<span class="jill"></span>0 ； 正数的原码、反码、补码相同。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">注意：计算算在运算的时候，都是以补码的方式来运算的。</span></div></div><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="JavaScript" class="marker"></div><pre><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>计算机运行
将<span class="token number">1</span> 与<span class="token operator">-</span><span class="token number">2</span>都转为补码，然后进行二进制的<span class="token operator">+</span>运算。再将结果由补码到原码（<span class="token operator">-</span><span class="token number">1</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token parameter">反码</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token parameter">符号位除外取反</span> <span class="token arrow operator">=></span> <span class="token parameter">原码</span> <span class="token arrow operator">=></span> 十进制  ）</pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap">视频：</span><span class="inline-wrap"><a href="https://www.bilibili.com/video/BV17y4y1275u"><span>https://www.bilibili.com/video/BV17y4y1275u</span></a></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.12 &gt;&gt;  &gt;&gt;&gt;</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">对应右移和无符号右移</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16520002231541652000222829.png" style="width: 844.6666666666666px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.13 HashMap<span class="jill"></span>与<span class="jill"></span>HashTable   </span><span class="inline-wrap"><b>ConcurrentHashMap</b></span><span class="inline-wrap">区别</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashMap<span class="jill"></span>是线程不安全的，而<span class="jill"></span>HashTable<span class="jill"></span>与<span class="jill"></span>ConcurrentMap 都是线程安全的，只不过实现线程安全的方法不同。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashTable<span class="jill"></span>一般现在不建议用 HashTable, ①是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用<span class="jill"></span>HashTable。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">HashTable 使用的是 Synchronized 关键字修饰，ConcurrentHashMap 是<span class="jill"></span>JDK1.7<span class="jill"></span>使用了锁分段技术来保证线程安全的。JDK1.8ConcurrentHashMap<span class="jill"></span>取消了<span class="jill"></span>Segment<span class="jill"></span>分段锁，采用<span class="jill"></span>CAS<span class="jill"></span>和<span class="jill"></span>synchronized<span class="jill"></span>来保证并发安全。数据结构跟<span class="jill"></span>HashMap1.8<span class="jill"></span>的结构类似，数组<span class="jill"></span>+<span class="jill"></span>链表/红黑二叉树。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 class="wolai-block"><span class="inline-wrap">4.0 MQ<span class="jill"></span>面试题</span></h3><h4 class="wolai-block"><span class="inline-wrap">4.1RabbitMQ 上的⼀个 queue 中存放的 message 是否有数量限制？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">可以认为是⽆限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.2 如何确保消息不丢失？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">将交换器/队列的<span class="jill"></span>durable<span class="jill"></span>属性设置为<span class="jill"></span>true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会⾃动创建）。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.3<span class="jill"></span>如何确保消息正确地发送⾄<span class="jill"></span>RabbitMQ？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">将信道设置成<span class="jill"></span>confirm<span class="jill"></span>模式（发送⽅确认模式），则所有在信道上发布的消息都会被指派⼀个唯⼀的<span class="jill"></span>ID。⼀旦消息被投递到⽬的队列后，或者消息被写⼊磁盘后（可持久化的消息），信道会发送⼀个确认给⽣产者（包含消息唯⼀<span class="jill"></span>ID）。如果<span class="jill"></span>RabbitMQ<span class="jill"></span>发⽣内部错误从⽽导致消息丢失，会发送⼀条<span class="jill"></span>nack（not acknowledged，未确认）消息。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">4.4 如何确保消息接收⽅消费了消息？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>接收⽅消息确认机制</b></span><span class="inline-wrap">：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ<span class="jill"></span>才能安全地把消息从队列中删除。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.5 如何避免消息重复投递或重复消费？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">使用消息的全局<span class="jill"></span>ID，在消费消息时判断之前是否已消费了该消息，如果消息就不再消费，从而避免重复消费。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.6 消息基于什么传输？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">RabbitMQ<span class="jill"></span>使⽤信道的⽅式来传输数据。信道是建⽴在真实的<span class="jill"></span>TCP<span class="jill"></span>连接内的虚拟连接，且每条<span class="jill"></span>TCP<span class="jill"></span>连接上的信道数量没有限制。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.7 .Queue<span class="jill"></span>队列？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Queue:RabbitMQ<span class="jill"></span>的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</span></div></div><h4 class="wolai-block"><span class="inline-wrap">4.8.Exchange<span class="jill"></span>交换器？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">Exchange:生产者将消息发送到交换器，有交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.9 RoutingKey<span class="jill"></span>路由键？</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">生产者将消息发送给交换器的时候，会指定一个<span class="jill"></span>RoutingKey,用来指定这个消息的路由规则，这个<span class="jill"></span>RoutingKey<span class="jill"></span>需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h4 class="wolai-block"><span class="inline-wrap">4.10  交换机类型</span></h4><div class="wolai-block wolai-text"><div><span class="inline-wrap">fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">direct:把消息路由到<span class="jill"></span>BindingKey<span class="jill"></span>和<span class="jill"></span>RoutingKey<span class="jill"></span>完全匹配的队列中。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">topic:</span></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>