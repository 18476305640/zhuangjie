<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>数据结构与算法 - wolai 笔记</title><link rel="shortcut icon" href="media/data-structure_1.png"></link></head><body><header><div class="image has" style="background-position-y: 50%; background-image: url(&quot;https://cdn.wostatic.cn/cover/gradient/dBaT4z5Rkf4Fy8ofX6384X.jpg&quot;)"></div><div class="title"><div class="banner"><div class="icon icon-image" style="background-image: url(&quot;media/data-structure.png&quot;)"></div></div><div data-title="数据结构与算法" class="main-title"></div></div></header><article><h2 class="wolai-block"><span class="inline-wrap">1.0<span class="jill"></span>概述</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap">1968<span class="jill"></span>年美国高德纳教授在所写的书中，系统阐述了...开创了数据结构的课程体系 。同年，数据结构作为一门独立的课程。之后<span class="jill"></span>70<span class="jill"></span>年代初，出现了大型程序应用数据结构与算法，算法得到人们的重视，程序设计的实质是对确定的问题选择一种好的结构，加上设计 一种好的算法。可见数据结构在程序设计中占据了重要的地位 。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16419904787941641990478769.png" style="width: 760px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>数据</code></span><span class="inline-wrap">  不仅仅包括整数、实型（浮点型） 数值 类型，还包括字符及声音、图像、视频等非数值类型，是计算机中可以操作的对象，</span><span class="red inline-wrap">能被计算机识别，并可输入给计算机处理</span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>对数据的操作</code></span><span class="inline-wrap"> 数值型可以用来计算 ，字符数据类型，就需要进行非数值的处理，面声音、图像 、视频其实是可以通过编码的手段变成字符数据来处理的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>数据元素&amp;数据项</code></span><span class="inline-wrap">  数据项可以看作是一行记录中的一列，就像一个人，这个人的姓名是数据项，当然性别、身份证号也可以是，它是数据不可分割的最小单位。而这个人则是数据元素，它是数据项的集合，是有一定意义的基本单位。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>数据对象</code></span><span class="inline-wrap"> 数据对象就是“数据”， 即是数据元素的集合。</span></div></div><div class="wolai-block wolai-text"><div><span class="red inline-wrap"><code>数据结构</code></span><span class="inline-wrap">  这里的“结构”就是指“关系”，就像“组成分子的原子之间的排列方式”，即“不同数据元素之间不是独立的，而是存在特定的关系，我们称这些关系为结构”，即”相互之间存在一种或多种特定关系的数据元素的集合“，即”数据结构是</span><span class="red inline-wrap">数据的组织形式</span><span class="inline-wrap">“， </span><span class="green inline-wrap">而我们要学的就是它们的”组织形式” </span><span class="inline-wrap">！</span></div></div><h3 class="wolai-block"><span class="inline-wrap">逻辑结构与物理结构</span></h3><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16419906469091641990646884.png" style="width: 661.8181818181819px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>逻辑结构</code></span><span class="inline-wrap"> 前面我们说了数据结构就是数据的组织形式，但具体有哪些组织形式呢，这就是我们数据结构主要研究的问题——逻辑结构。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">圆型表示的是数据元素，连线表示关系。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1） 集合结构：</span><span class="red inline-wrap"> 除了属于同一个集合外，它们之间没有其它关系</span><span class="inline-wrap">。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/1641908274451%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BF.png" style="width: 296.4545454545455px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2）线性结构：数据元素之间是一对一的关系</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/1641908964988%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BF%202.png" style="width: 295.90909090909093px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">3）树形结构：数据元素之间是一对多的关系的层次关系</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/1641909624741%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BF3.png" style="width: 315.81818181818187px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">5）图形结构：数据元素之间是多对多的关系</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/1641910249417%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BF%204.png" style="width: 316.0909090909091px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>物理结构</code></span><span class="inline-wrap">   也叫存储结构，是指</span><span class="red inline-wrap">计算机中的存储形式</span><span class="inline-wrap">，即在计算机存储器中的，</span><span class="red inline-wrap">存储器针对的是内存</span><span class="inline-wrap">而言的。而非硬盘、软盘、光盘等外部存储器。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">我们实质关心的是数据元素逻辑存储结构，这才是最为关键的。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">1）顺序存储结构</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">是把数据元素存放在地址</span><span class="red inline-wrap">连续的存储单元里</span><span class="inline-wrap">，其数据间的逻辑关系和物理关系是一致的。数组就是这样的顺序存储结构。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16419130735481641913073536.png" style="width: 477.09090909090907px"/></figure></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">2）链式存储结构</span></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">现在如银行、医院等地方,设置了排队系统,也就是每个人去了,先领一个号,等着叫号,叫到时去办理业务或看病。在等待的时候,你爱在哪在哪,可以坐着、站着或者走动,甚至出去逛一圈,只要及时回来就行。你关注的是前一个号有没有被叫到,叫到了,下一个就轮到了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">链式存储结构：是把数据存</span><span class="red inline-wrap">放在任意的存储单元里</span><span class="inline-wrap">，这组单元可以是连续的，也可以是不连续的。</span></div></div><div class="wolai-block wolai-center"><figure style="width: 100%"><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16419138827271641913882712.png" style="width: 340.3636363636364px"/></figure></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">显然,链式存储就灵活多了,数据存在哪里不重要,只要有一个</span><span class="green inline-wrap">指针存放了相应的地址</span><span class="inline-wrap">就能找到它了。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">逻辑结构是面向问题的,而物理结构就是面向计算机的,其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">数据类型与抽象数据类型</span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>数据类型</code></span><span class="inline-wrap"> 为什么要有数据类型呢？考虑的是，在计算机中,内存也不是无限大的,你要计算一个如<span class="jill"></span>1+1=2、3+5=8<span class="jill"></span>这样的整型数字的加减乘除运算,显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑,要对数据进行分类,分出来多种数据类型。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">数据类型分为</span><span class="red inline-wrap">原子类型与结构类型：</span><span class="inline-wrap">原子类型比如整形，实型，字符型等，而结构数据类型可以分为若干数据类型的混杂。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>抽象数据类型</code></span><span class="inline-wrap">  (Abstract Data Type, ADT)  是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性,而与其在计算机内部如何表示和实现无关。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">抽象数据类型不仅仅指那些已经定义并实现的数据类型,还可以是计算机编程者在设计软件程序时自己定义的数据类型,比如我们编写关于计算机绘图或者地图类的软件系统,经常都会用到坐标。也就是说,总是有成对出现的<span class="jill"></span>x<span class="jill"></span>和<span class="jill"></span>y,在<span class="jill"></span>3D<span class="jill"></span>系统中还有<span class="jill"></span>z<span class="jill"></span>出现,既然这三个整型数字是始终在一起出现,我们就定义一个叫 point<span class="jill"></span>的抽象数据类型,它有<span class="jill"></span>x、y、z<span class="jill"></span>三个整型变量,这样我们很方便地操作一个 point<span class="jill"></span>数据变量就能知道这一点的坐标了。</span></div></div><h2 class="wolai-block"><span class="inline-wrap">2.0<span class="jill"></span>算法</span></h2><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>算法</code></span><span class="inline-wrap">  算法就是解决问题的方法，这个方法表现为求解步骤的描述，在计算机表现为指令的有限序列，并且每条指令表示为一个或多个操作。没有用的算法，就像没有包治百病的药一样。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>算法的特征</code></span><span class="inline-wrap"> 有五个，输入、输出、有穷性、确定性和可行性。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">输入输出：输出可以是打印输出或返回一个或多个值等。不然这个算法也就没了意义。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">有穷性：算法是执行有限的步骤得出结果的。自动结束而不会出现无限循环。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">确定性：相同的输入只能有唯一的输出结果。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可行性：算法的每一步都必须是可行的,也就是说,每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行,并得到正确的结果。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><code>对算法的要求</code></span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">算法程序本身没有语法错误，并且对合法的输入、不合法甚至刁难的测试数据都有满足要求的输出结果。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">可读性：算法设计的另一目的是为了便于阅读、理解和交流。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">健壮性：当输入数据不合法时,算法也能做出相关处理,而不是产生异常或莫名其妙的结果。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">时间效率高和存储量低：时间效率高的算法可以节省很多不必须的支出。设计算法应该尽量满足时间效率高和存储量低的需求。</span></div></div><h3 class="wolai-block"><span class="inline-wrap">算法效率的度量方法 </span></h3><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>事后统计方法</b></span><span class="inline-wrap">：利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这种方法显然</span><span class="green inline-wrap">有很大的缺陷</span><span class="inline-wrap">：这种比较方法依赖计算机硬件和软件的等环境因素，且跟运算的数据规模有很大的关系。所以我们考虑</span><span class="green inline-wrap">不予采纳！</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"><b>事前统计方法</b></span></div></div><ol class="wolai-block"><li><div class="marker"></div><span class="inline-wrap">算法是解决问题一思路，还不是程序。 算法要有正确性、可读性、健壮性、高效性与低存储量。</span></li><li><div class="marker"></div><span class="inline-wrap">算法的时间复杂度：问题的规模、语句的频度。 使用<span class="jill"></span>O(f(n))表示 ，常用的时间复杂性有：O(1)、O(logn)、O(n)、O( nlogn)、O(n^2)、O(n^3)、O(2^n)</span><div class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.bilibili.com/video/BV1nE411x7qP?from=search&amp;seid=454824815628251978&amp;spm_id_from=333.337.0.0"><span>时间复杂度教程</span></a></span><span class="inline-wrap">， 总结：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">① T(n) =次数表示式，表示的是执行的次数； O(n) 通过<span class="jill"></span>T(n)的抓大头等操作后这就是时间复杂度，有<span class="jill"></span>O(1)、O(logn)、O(n)、O( nlogn)、O(n^2)、O(n^3)、O(2^n) 这些， 对应的结构是：</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">O(1) : 有<span class="jill"></span>if else<span class="jill"></span>语句的，取大的，没有<span class="jill"></span>for<span class="jill"></span>循环体的最上而下的时间复杂性是<span class="jill"></span>O(n)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">O(n): 有一层<span class="jill"></span>for<span class="jill"></span>循环的</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">O(n^a): 有<span class="jill"></span>a<span class="jill"></span>层<span class="jill"></span>for 循环的</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">O(logn) : for (int i=1; i &lt; n; i*=2) {..} T(n)=log2n-1 时间复杂度为<span class="jill"></span>O(logn)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">② 注意，1、如果有两个同级的<span class="jill"></span>for<span class="jill"></span>循环取最大的。 O(n) &lt; O(n^2)</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">③ 特别地：for (int i=0; i &lt; n; ++i) {</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">for (int j=i; j &lt; n; ++j) {...}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">}</span></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap">这种只需算最深层执行的次数即可，T(n) = n + (n-1) + (n-2) + (n-3) + ... +2+1 = Sn = [(1+n)n]/2 即时间复杂度为<span class="jill"></span>O(n^2), 也是符合<span class="jill"></span>a<span class="jill"></span>层循环，时间复杂度为<span class="jill"></span>O(n^a) 的。</span></div></div></li></ol><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 class="wolai-block"><span class="inline-wrap">3.0<span class="jill"></span>树</span></h2><h3 class="wolai-block"><span class="inline-wrap">3.1<span class="jill"></span>二叉树的遍历</span></h3><code-block class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre>    <span class="token doc-comment comment">/**
     * 关于遍历：前中后只是访问的位置不同+遍历的左右的前后不同（要有单元性的思想），代码一样，层序遍历更简单，层序遍历是要记住的遍历。
     * 层序遍历（while）: 自上而下，从左到右
     * 前序遍历（递归）： [根]左右
     * 中序遍历（递归）: 左[根]右
     * 后序遍历（递归）： 左右[根]
     */</span>
    <span class="token comment">//前序遍历——“根左右”，递归左右子树都要查看是否暂停（visitor.stop）</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> node<span class="token punctuation">,</span> <span class="token class-name">Visitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//如果要操作的节点不存在（下面传递的左右子树），直接返回</span>
        visitor<span class="token punctuation">.</span>stop <span class="token operator">=</span> visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取根节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归左子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归右子树</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//后序遍历——即“左右根”</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">postderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> node<span class="token punctuation">,</span> <span class="token class-name">Visitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//如果要操作的节点不存在（下面传递的左右子树），直接返回</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">postderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归左子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">postderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//递归右子树</span>
        visitor<span class="token punctuation">.</span>stop <span class="token operator">=</span> visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问根节点</span>


    <span class="token punctuation">}</span>
    <span class="token comment">//中序遍历——“左根右”  升降序</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> node<span class="token punctuation">,</span><span class="token class-name">Visitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//如果要操作的节点不存在（下面传递的左右子树），直接返回</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归左子树</span>
        visitor<span class="token punctuation">.</span>stop <span class="token operator">=</span> visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问根节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归右子树</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//层序遍历——没有用到递归！！</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token class-name">LevelOrderTraversal</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> node<span class="token punctuation">,</span><span class="token class-name">Visitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span><span class="token punctuation">></span></span> us <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//需要用到一个队列</span>
        us<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//要存入根节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>us<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//开始进行有机的poll-push</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> uNode <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//poll一个节点，</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>uNode<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//第个节点都会弹出，且按自上而下从左到右输出，我们只需读取每个弹出的节点即可</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>uNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> us<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>uNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//push进该节点的左节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>uNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> us<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>uNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//push进该节点的右节点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></pre></div></code-block><div class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></div><div class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>